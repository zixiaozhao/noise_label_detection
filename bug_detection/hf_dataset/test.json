[
  {
    "project": "Jsoup",
    "bug_id": "67",
    "file": "org/jsoup/parser/HtmlTreeBuilder.java",
    "snippet": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.FormElement;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.select.Elements;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.jsoup.helper.StringUtil.inSorted;\nimport static org.jsoup.helper.StringUtil.sort;\n\n/**\n * HTML Tree Builder; creates a DOM from Tokens.\n */\npublic class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches. must be sorted, used in inSorted\n    private static final String[] TagsSearchInScope = sort(new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"});\n    private static final String[] TagSearchList = sort(new String[]{\"ol\", \"ul\"});\n    private static final String[] TagSearchButton = sort(new String[]{\"button\"});\n    private static final String[] TagSearchTableScope = sort(new String[]{\"html\", \"table\"});\n    private static final String[] TagSearchSelectScope = sort(new String[]{\"optgroup\", \"option\"});\n    private static final String[] TagSearchEndTags = sort(new String[]{\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"});\n    private static final String[] TagSearchSpecial = sort(new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n        \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n        \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n        \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n        \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n        \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n        \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n        \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"});\n\n    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n",
    "label": "clean",
    "id": "efa06594-ec3b-41d4-a39f-0d245c91c9b5"
  },
  {
    "project": "Jsoup",
    "bug_id": "11",
    "file": "org/jsoup/select/Selector.java",
    "snippet": "    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param roots root elements to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else if (tq.matches(\":has(\")) {\n            elements.addAll(root.getAllElements());\n        } else {\n            addElements(findElements()); // chomp first element matcher off queue \n        }            \n               \n",
    "label": "clean",
    "id": "13cb6aba-76b1-46c5-932e-a96005112024"
  },
  {
    "project": "Collections",
    "bug_id": "12",
    "file": "org/apache/commons/collections/ExtendedProperties.java",
    "snippet": "    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            super.put(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n",
    "label": "buggy",
    "id": "eea67ae6-5dbf-4d08-80a8-c7b1e72cbd03"
  },
  {
    "project": "Math",
    "bug_id": "48",
    "file": "org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
    "snippet": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Detect early that algorithm is stuck, instead of waiting\n                    // for the maximum number of iterations to be exceeded.\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                    break;\n                default:\n                    // Should never happen.\n",
    "label": "clean",
    "id": "74768659-3d5e-4175-adaf-d519a49a0421"
  },
  {
    "project": "Cli",
    "bug_id": "28",
    "file": "org/apache/commons/cli/Parser.java",
    "snippet": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n",
    "label": "buggy",
    "id": "52b93159-ee10-4d96-b95d-1c57bf3d1991"
  },
  {
    "project": "Collections",
    "bug_id": "18",
    "file": "org/apache/commons/collections/set/ListOrderedSet.java",
    "snippet": "    /**\n     * Gets an unmodifiable view of the order of the Set.\n     * \n     * @return an unmodifiable list view\n     */\n    public List<E> asList() {\n        return UnmodifiableList.unmodifiableList(setOrder);\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        collection.clear();\n        setOrder.clear();\n    }\n\n    @Override\n    public OrderedIterator<E> iterator() {\n        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n    }\n\n    @Override\n    public boolean add(E object) {\n        if (collection.add(object)) {\n            setOrder.add(object);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> coll) {\n        boolean result = false;\n        for (E e : coll) {\n            result |= add(e);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean remove(Object object) {\n        boolean result = collection.remove(object);\n        if (result) {\n            setOrder.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> coll) {\n        boolean result = false;\n        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n            result |= remove(it.next());\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> coll) {\n        Set<Object> collectionRetainAll = new HashSet<Object>();\n        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n            Object next = it.next();\n            if (collection.contains(next)) {\n                collectionRetainAll.add(next);\n            }\n",
    "label": "clean",
    "id": "2af08df4-603a-4eee-8e86-69391b04241e"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "70",
    "file": "com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java",
    "snippet": "    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(prop.getName());\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n",
    "label": "buggy",
    "id": "48f51652-3062-44da-878b-63e34294b6f6"
  },
  {
    "project": "Chart",
    "bug_id": "22",
    "file": "org/jfree/data/KeyedObjects2D.java",
    "snippet": "    /**\n     * Returns the object for the given row and column keys.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The object (possibly <code>null</code>).\n     * \n     * @throws IllegalArgumentException if <code>rowKey<code> or \n     *         <code>columnKey</code> is <code>null</code>.\n     * @throws UnknownKeyException if <code>rowKey</code> or \n     *         <code>columnKey</code> is not recognised.\n     */\n    public Object getObject(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        int row = this.rowKeys.indexOf(rowKey);\n        if (row < 0) {\n            throw new UnknownKeyException(\"Row key (\" + rowKey \n                    + \") not recognised.\");\n        }\n        int column = this.columnKeys.indexOf(columnKey);\n        if (column < 0) {\n            throw new UnknownKeyException(\"Column key (\" + columnKey \n                    + \") not recognised.\");\n        }\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n        int index = rowData.getIndex(columnKey);\n        if (index >= 0) {\n            return rowData.getObject(index);\n        }\n",
    "label": "clean",
    "id": "6735c09a-74ed-4e1a-8290-18a5b7fcecdc"
  },
  {
    "project": "Mockito",
    "bug_id": "12",
    "file": "org/mockito/internal/util/reflection/GenericMaster.java",
    "snippet": "    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                //in case of nested generics we don't go deep\n                return (Class) ((ParameterizedType) actual).getRawType();\n            }\n",
    "label": "clean",
    "id": "174e15cc-f164-462d-a2d3-05f40e81dc52"
  },
  {
    "project": "Lang",
    "bug_id": "17",
    "file": "org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
    "snippet": "    /**\n     * Helper for non-Writer usage. \n     * @param input CharSequence to be translated\n     * @return String output of translation\n     */\n    public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            throw new RuntimeException(ioe);\n        }\n    }\n\n    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n",
    "label": "clean",
    "id": "a2b91610-729c-41fe-90c5-b1aef323b846"
  },
  {
    "project": "Closure",
    "bug_id": "5",
    "file": "com/google/javascript/jscomp/InlineObjectLiterals.java",
    "snippet": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n          if (gramps.isDelProp()) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n",
    "label": "clean",
    "id": "365c8b10-9361-4c96-a4f9-a965e8d0c71f"
  },
  {
    "project": "Closure",
    "bug_id": "12",
    "file": "com/google/javascript/jscomp/MaybeReachingVariableUse.java",
    "snippet": "  /**\n   * The join is a simple union because of the \"may be\" nature of the analysis.\n   *\n   * Consider: A = 1; if (x) { A = 2 }; alert(A);\n   *\n   * The read of A \"may be\" exposed to A = 1 in the beginning.\n   */\n  private static class ReachingUsesJoinOp implements JoinOp<ReachingUses> {\n    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n      ReachingUses result = new ReachingUses();\n      for (ReachingUses uses : from) {\n        result.mayUseMap.putAll(uses.mayUseMap);\n      }\n      return result;\n    }\n  }\n\n  @Override\n  boolean isForward() {\n    return false;\n  }\n\n  @Override\n  ReachingUses createEntryLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses createInitialEstimateLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n\n    // If there's an ON_EX edge, this cfgNode may or may not get executed.\n    // We can express this concisely by just pretending this happens in\n    // a conditional.\n    boolean conditional = hasExceptionHandler(n);\n    computeMayUse(n, n, output, conditional);\n\n    return output;\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n",
    "label": "clean",
    "id": "99942954-3a74-43df-b130-95b1ccb073a6"
  },
  {
    "project": "Math",
    "bug_id": "42",
    "file": "org/apache/commons/math/optimization/linear/SimplexTableau.java",
    "snippet": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n",
    "label": "buggy",
    "id": "366caed4-7bc6-438d-92c7-a6e1235aab12"
  },
  {
    "project": "Lang",
    "bug_id": "19",
    "file": "org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.text.translate;\n\nimport java.io.IOException;\nimport java.io.Writer;\n\n/**\n * Translate XML numeric entities of the form &#[xX]?\\d+;? to \n * the specific codepoint.\n *\n * Note that the semi-colon is optional.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class NumericEntityUnescaper extends CharSequenceTranslator {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n",
    "label": "clean",
    "id": "2a1176f9-2758-41a4-8e99-0afdf4e5a33f"
  },
  {
    "project": "Jsoup",
    "bug_id": "93",
    "file": "org/jsoup/nodes/FormElement.java",
    "snippet": "    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (type.equalsIgnoreCase(\"button\")) continue; // browsers don't submit these\n\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n",
    "label": "clean",
    "id": "dbb2f233-1527-46d5-8bc4-71f77de0d4c5"
  },
  {
    "project": "Compress",
    "bug_id": "41",
    "file": "org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
    "snippet": "    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(final InputStream inputStream,\n                                 final String encoding,\n                                 final boolean useUnicodeExtraFields,\n                                 final boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n",
    "label": "buggy",
    "id": "97f104fa-9cbe-4bc8-affa-b4fc8a67f14d"
  },
  {
    "project": "JxPath",
    "bug_id": "12",
    "file": "org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java",
    "snippet": "/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n",
    "label": "clean",
    "id": "f18e7ca1-294f-4fea-bd6b-b70207cdea06"
  },
  {
    "project": "Compress",
    "bug_id": "25",
    "file": "org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
    "snippet": "    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n",
    "label": "buggy",
    "id": "7ddbdb5d-9cd3-43e4-98b8-07b8c5731aaf"
  },
  {
    "project": "Math",
    "bug_id": "38",
    "file": "org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java",
    "snippet": "    /** {@inheritDoc} */\n    @Override\n    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        // Validity checks.\n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }\n\n    /**\n     *     This subroutine seeks the least value of a function of many variables,\n     *     by applying a trust region method that forms quadratic models by\n     *     interpolation. There is usually some freedom in the interpolation\n     *     conditions, which is taken up by minimizing the Frobenius norm of\n     *     the change to the second derivative of the model, beginning with the\n     *     zero matrix. The values of the variables are constrained by upper and\n     *     lower bounds. The arguments of the subroutine are as follows.\n     *\n     *     N must be set to the number of variables and must be at least two.\n     *     NPT is the number of interpolation conditions. Its value must be in\n     *       the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n     *       recommended.\n     *     Initial values of the variables must be set in X(1),X(2),...,X(N). They\n     *       will be changed to the values that give the least calculated F.\n     *     For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper\n     *       bounds, respectively, on X(I). The construction of quadratic models\n     *       requires XL(I) to be strictly less than XU(I) for each I. Further,\n     *       the contribution to a model from changes to the I-th variable is\n     *       damaged severely by rounding errors if XU(I)-XL(I) is too small.\n     *     RHOBEG and RHOEND must be set to the initial and final values of a trust\n     *       region radius, so both must be positive with RHOEND no greater than\n     *       RHOBEG. Typically, RHOBEG should be about one tenth of the greatest\n     *       expected change to a variable, while RHOEND should indicate the\n     *       accuracy that is required in the final values of the variables. An\n     *       error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,\n     *       is less than 2*RHOBEG.\n     *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n     *     The array W will be used for working space. Its length must be at least\n     *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     * @return the value of the objective at the optimum.\n     */\n    private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n\n        // Return if there is insufficient space between the bounds. Modify the\n        // initial X if necessary in order to avoid conflicts between the bounds\n        // and the construction of the first quadratic model. The lower and upper\n        // bounds on moves from the updated X are set now, in the ISL and ISU\n        // partitions of W, in order to provide useful and exact information about\n        // components of X that become within distance RHOBEG from their bounds.\n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    // Computing MAX\n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    // Computing MIN\n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        // Make the call of BOBYQB.\n\n        return bobyqb(lowerBound, upperBound);\n    } // bobyqa\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN\n     *       are identical to the corresponding arguments in SUBROUTINE BOBYQA.\n     *     XBASE holds a shift of origin that should reduce the contributions\n     *       from rounding errors to values of the model and Lagrange functions.\n     *     XPT is a two-dimensional array that holds the coordinates of the\n     *       interpolation points relative to XBASE.\n     *     FVAL holds the values of F at the interpolation points.\n     *     XOPT is set to the displacement from XBASE of the trust region centre.\n     *     GOPT holds the gradient of the quadratic model at XBASE+XOPT.\n     *     HQ holds the explicit second derivatives of the quadratic model.\n     *     PQ contains the parameters of the implicit second derivatives of the\n     *       quadratic model.\n     *     BMAT holds the last N columns of H.\n     *     ZMAT holds the factorization of the leading NPT by NPT submatrix of H,\n     *       this factorization being ZMAT times ZMAT^T, which provides both the\n     *       correct rank and positive semi-definiteness.\n     *     NDIM is the first dimension of BMAT and has the value NPT+N.\n     *     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively.\n     *       All the components of every XOPT are going to satisfy the bounds\n     *       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when\n     *       XOPT is on a constraint boundary.\n     *     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the\n     *       vector of variables for the next call of CALFUN. XNEW also satisfies\n     *       the SL and SU constraints in the way that has just been mentioned.\n     *     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW\n     *       in order to increase the denominator in the updating of UPDATE.\n     *     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT.\n     *     VLAG contains the values of the Lagrange functions at a new point X.\n     *       They are part of a product that requires VLAG to be of length NDIM.\n     *     W is a one-dimensional array that is used for working space. Its length\n     *       must be at least 3*NDIM = 3*(NPT+N).\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     * @return the value of the objective at the optimum.\n     */\n    private double bobyqb(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        // Set some constants.\n        // Parameter adjustments\n\n        // Function Body\n\n        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n        // BMAT and ZMAT for the first iteration, with the corresponding values of\n        // of NF and KOPT, which are the number of calls of CALFUN so far and the\n        // index of the interpolation point at the trust region centre. Then the\n        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n        // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            // Computing 2nd power\n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        // Complete the settings that are required for the iterative procedure.\n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        // Update GOPT if necessary before the first iteration and after each\n        // call of RESCUE that makes a call of CALFUN.\n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } // bobyqb\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have\n     *       the same meanings as the corresponding arguments of BOBYQB.\n     *     KOPT is the index of the optimal interpolation point.\n     *     KNEW is the index of the interpolation point that is going to be moved.\n     *     ADELT is the current trust region bound.\n     *     XNEW will be set to a suitable new position for the interpolation point\n     *       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region\n     *       bounds and it should provide a large denominator in the next call of\n     *       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the\n     *       straight lines through XOPT and another interpolation point.\n     *     XALT also provides a large value of the modulus of the KNEW-th Lagrange\n     *       function subject to the constraints that have been mentioned, its main\n     *       difference from XNEW being that XALT-XOPT is a constrained version of\n     *       the Cauchy step within the trust region. An exception is that XALT is\n     *       not calculated if all components of GLAG (see below) are zero.\n     *     ALPHA will be set to the KNEW-th diagonal element of the H matrix.\n     *     CAUCHY will be set to the square of the KNEW-th Lagrange function at\n     *       the step XALT-XOPT from XOPT for the vector XALT that is returned,\n     *       except that CAUCHY is set to zero if XALT is not calculated.\n     *     GLAG is a working space vector of length N for the gradient of the\n     *       KNEW-th Lagrange function at XOPT.\n     *     HCOL is a working space vector of length NPT for the second derivative\n     *       coefficients of the KNEW-th Lagrange function.\n     *     W is a working space vector of length 2N that is going to hold the\n     *       constrained Cauchy step from XOPT of the Lagrange function, followed\n     *       by the downhill version of XALT when the uphill step is calculated.\n     *\n     *     Set the first NPT components of W to the leading elements of the\n     *     KNEW-th column of the H matrix.\n     * @param knew\n     * @param adelt\n     */\n    private double[] altmov(\n            int knew,\n            double adelt\n    ) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        final ArrayRealVector glag = new ArrayRealVector(n);\n        final ArrayRealVector hcol = new ArrayRealVector(npt);\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(n);\n\n        for (int k = 0; k < npt; k++) {\n            hcol.setEntry(k, ZERO);\n        }\n        for (int j = 0, max = npt - n - 1; j < max; j++) {\n            final double tmp = zMatrix.getEntry(knew, j);\n            for (int k = 0; k < npt; k++) {\n                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));\n            }\n        }\n        final double alpha = hcol.getEntry(knew);\n        final double ha = HALF * alpha;\n\n        // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n\n        for (int i = 0; i < n; i++) {\n            glag.setEntry(i, bMatrix.getEntry(knew, i));\n        }\n        for (int k = 0; k < npt; k++) {\n            double tmp = ZERO;\n            for (int j = 0; j < n; j++) {\n                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n            }\n            tmp *= hcol.getEntry(k);\n            for (int i = 0; i < n; i++) {\n                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));\n            }\n        }\n\n        // Search for a large denominator along the straight lines through XOPT\n        // and another interpolation point. SLBD and SUBD will be lower and upper\n        // bounds on the step along each of these lines in turn. PREDSQ will be\n        // set to the square of the predicted denominator for each line. PRESAV\n        // will be set to the largest admissible value of PREDSQ that occurs.\n\n        double presav = ZERO;\n        double step = Double.NaN;\n        int ksav = 0;\n        int ibdsav = 0;\n        double stpsav = 0;\n        for (int k = 0; k < npt; k++) {\n            if (k == trustRegionCenterInterpolationPointIndex) {\n                continue;\n            }\n            double dderiv = ZERO;\n            double distsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                dderiv += glag.getEntry(i) * tmp;\n                distsq += tmp * tmp;\n            }\n            double subd = adelt / Math.sqrt(distsq);\n            double slbd = -subd;\n            int ilbd = 0;\n            int iubd = 0;\n            final double sumin = Math.min(ONE, subd);\n\n            // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                if (tmp > ZERO) {\n                    if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = -i - 1;\n                    }\n                    if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        // Computing MAX\n                        subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = i + 1;\n                    }\n                } else if (tmp < ZERO) {\n                    if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = i + 1;\n                    }\n                    if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        // Computing MAX\n                        subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = -i - 1;\n                    }\n                }\n            }\n\n            // Seek a large modulus of the KNEW-th Lagrange function when the index\n            // of the other interpolation point on the line through XOPT is KNEW.\n\n            step = slbd;\n            int isbd = ilbd;\n            double vlag = Double.NaN;\n            if (k == knew) {\n                final double diff = dderiv - ONE;\n                vlag = slbd * (dderiv - slbd * diff);\n                final double d1 = subd * (dderiv - subd * diff);\n                if (Math.abs(d1) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = d1;\n                    isbd = iubd;\n                }\n                final double d2 = HALF * dderiv;\n                final double d3 = d2 - diff * slbd;\n                final double d4 = d2 - diff * subd;\n                if (d3 * d4 < ZERO) {\n                    final double d5 = d2 * d2 / diff;\n                    if (Math.abs(d5) > Math.abs(vlag)) {\n                        step = d2 / diff;\n                        vlag = d5;\n                        isbd = 0;\n                    }\n                }\n\n                // Search along each of the other lines through XOPT and another point.\n\n            } else {\n                vlag = slbd * (ONE - slbd);\n                final double tmp = subd * (ONE - subd);\n                if (Math.abs(tmp) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = tmp;\n                    isbd = iubd;\n                }\n                if (subd > HALF) {\n                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n                        step = HALF;\n                        vlag = ONE_OVER_FOUR;\n                        isbd = 0;\n                    }\n                }\n                vlag *= dderiv;\n            }\n\n            // Calculate PREDSQ for the current line search and maintain PRESAV.\n\n            final double tmp = step * (ONE - step) * distsq;\n            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);\n            if (predsq > presav) {\n                presav = predsq;\n                ksav = k;\n                stpsav = step;\n                ibdsav = isbd;\n            }\n        }\n\n        // Construct XNEW in a way that satisfies the bound constraints exactly.\n\n        for (int i = 0; i < n; i++) {\n            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));\n            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));\n        }\n        if (ibdsav < 0) {\n            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));\n        }\n        if (ibdsav > 0) {\n            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));\n        }\n\n        // Prepare for the iterative method that assembles the constrained Cauchy\n        // step in W. The sum of squares of the fixed components of W is formed in\n        // WFIXSQ, and the free components of W are set to BIGSTP.\n\n        final double bigstp = adelt + adelt;\n        int iflag = 0;\n        double cauchy = Double.NaN;\n        double csave = ZERO;\n        while (true) {\n            double wfixsq = ZERO;\n            double ggfree = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                work1.setEntry(i, ZERO);\n                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) {\n                    work1.setEntry(i, bigstp);\n                    // Computing 2nd power\n                    ggfree += glagValue * glagValue;\n                }\n            }\n            if (ggfree == ZERO) {\n                return new double[] { alpha, ZERO };\n            }\n\n            // Investigate whether more components of W can be fixed.\n            final double tmp1 = adelt * adelt - wfixsq;\n            if (tmp1 > ZERO) {\n                step = Math.sqrt(tmp1 / ggfree);\n                ggfree = ZERO;\n                for (int i = 0; i < n; i++) {\n                    if (work1.getEntry(i) == bigstp) {\n                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);\n                        if (tmp2 <= lowerDifference.getEntry(i)) {\n                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            // Computing 2nd power\n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else if (tmp2 >= upperDifference.getEntry(i)) {\n                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            // Computing 2nd power\n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else {\n                            // Computing 2nd power\n                            final double d1 = glag.getEntry(i);\n                            ggfree += d1 * d1;\n                        }\n                    }\n                }\n            }\n\n            // Set the remaining free components of W and all components of XALT,\n            // except that W may be scaled later.\n\n            double gw = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                if (work1.getEntry(i) == bigstp) {\n                    work1.setEntry(i, -step * glagValue);\n                    final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));\n                } else if (work1.getEntry(i) == ZERO) {\n                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));\n                } else if (glagValue > ZERO) {\n                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));\n                } else {\n                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                gw += glagValue * work1.getEntry(i);\n            }\n\n            // Set CURV to the curvature of the KNEW-th Lagrange function along W.\n            // Scale W by a factor less than one if that can reduce the modulus of\n            // the Lagrange function at XOPT+W. Set CAUCHY to the final value of\n            // the square of this function.\n\n            double curv = ZERO;\n            for (int k = 0; k < npt; k++) {\n                double tmp = ZERO;\n                for (int j = 0; j < n; j++) {\n                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);\n                }\n                curv += hcol.getEntry(k) * tmp * tmp;\n            }\n            if (iflag == 1) {\n                curv = -curv;\n            }\n            if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO))) {\n                final double scale = -gw / curv;\n                for (int i = 0; i < n; i++) {\n                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));\n                }\n                // Computing 2nd power\n                final double d1 = HALF * gw * scale;\n                cauchy = d1 * d1;\n            } else {\n                // Computing 2nd power\n                final double d1 = gw + HALF * curv;\n                cauchy = d1 * d1;\n            }\n\n            // If IFLAG is zero, then XALT is calculated as before after reversing\n            // the sign of GLAG. Thus two XALT vectors become available. The one that\n            // is chosen is the one that gives the larger value of CAUCHY.\n\n            if (iflag == 0) {\n                for (int i = 0; i < n; i++) {\n                    glag.setEntry(i, -glag.getEntry(i));\n                    work2.setEntry(i, alternativeNewPoint.getEntry(i));\n                }\n                csave = cauchy;\n                iflag = 1;\n            } else {\n                break;\n            }\n        }\n        if (csave > cauchy) {\n            for (int i = 0; i < n; i++) {\n                alternativeNewPoint.setEntry(i, work2.getEntry(i));\n            }\n            cauchy = csave;\n        }\n\n        return new double[] { alpha, cauchy };\n    } // altmov\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n//                     throw new PathIsExploredException(); // XXX\n                }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n",
    "label": "clean",
    "id": "37ef9c62-4fe9-4e2c-9aa3-e54ccb67dd5e"
  },
  {
    "project": "Math",
    "bug_id": "5",
    "file": "org/apache/commons/math3/complex/Complex.java",
    "snippet": "    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n",
    "label": "buggy",
    "id": "52af5fd5-4e41-4e30-8bdb-522ca6cf0171"
  },
  {
    "project": "Math",
    "bug_id": "101",
    "file": "org/apache/commons/math/complex/ComplexFormat.java",
    "snippet": "    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Complex} object.\n     */\n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n",
    "label": "buggy",
    "id": "58b89a03-9357-4da8-a4a7-9685f5b4a5b0"
  },
  {
    "project": "Gson",
    "bug_id": "3",
    "file": "com/google/gson/internal/ConstructorConstructor.java",
    "snippet": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport com.google.gson.InstanceCreator;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.reflect.TypeToken;\n\n",
    "label": "buggy",
    "id": "18008a25-40be-45ff-a768-c7cc79fa1122"
  },
  {
    "project": "Chart",
    "bug_id": "4",
    "file": "org/jfree/chart/plot/XYPlot.java",
    "snippet": "    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n",
    "label": "buggy",
    "id": "a5328057-1e85-44e5-ae6e-c0468c044649"
  },
  {
    "project": "Math",
    "bug_id": "100",
    "file": "org/apache/commons/math/estimation/AbstractEstimator.java",
    "snippet": "    /**\n     * Get the Chi-Square value.\n     * @param problem estimation problem\n     * @return chi-square value\n     */\n    public double getChiSquare(EstimationProblem problem) {\n        WeightedMeasurement[] wm = problem.getMeasurements();\n        double chiSquare = 0;\n        for (int i = 0; i < wm.length; ++i) {\n            double residual = wm[i].getResidual();\n            chiSquare += residual * residual / wm[i].getWeight();\n        }\n        return chiSquare;\n    }\n\n    /**\n     * Get the covariance matrix of unbound estimated parameters.\n     * @param problem estimation problem\n     * @return covariance matrix\n     * @exception EstimationException if the covariance matrix\n     * cannot be computed (singular problem)\n     */\n    public double[][] getCovariances(EstimationProblem problem)\n      throws EstimationException {\n \n        // set up the jacobian\n        updateJacobian();\n\n        // compute transpose(J).J, avoiding building big intermediate matrices\n        final int rows = problem.getMeasurements().length;\n        final int cols = problem.getUnboundParameters().length;\n        final int max  = cols * rows;\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n",
    "label": "clean",
    "id": "4ec4ac10-3e9d-44e0-8683-191dac97a9ee"
  },
  {
    "project": "Jsoup",
    "bug_id": "86",
    "file": "org/jsoup/nodes/Comment.java",
    "snippet": "    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n",
    "label": "buggy",
    "id": "9bcfe24f-5a82-4b18-be68-0cd55a4fc20c"
  },
  {
    "project": "Closure",
    "bug_id": "116",
    "file": "com/google/javascript/jscomp/FunctionInjector.java",
    "snippet": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n",
    "label": "buggy",
    "id": "3bef546c-52db-40ee-80a4-09c4867f0e40"
  },
  {
    "project": "Closure",
    "bug_id": "44",
    "file": "com/google/javascript/jscomp/CodeConsumer.java",
    "snippet": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.rhino.Node;\n\n\n/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  boolean statementNeedsEnded = false;\n  boolean statementStarted = false;\n  boolean sawFunction = false;\n\n  /**\n   * Starts the source mapping for the given\n   * node at the current position.\n   */\n  void startSourceMapping(Node node) {\n  }\n\n  /**\n   * Finishes the source mapping for the given\n   * node at the current position.\n   */\n  void endSourceMapping(Node node) {\n  }\n\n  /**\n   * Provides a means of interrupting the CodeGenerator. Derived classes should\n   * return false to stop further processing.\n   */\n  boolean continueProcessing() {\n    return true;\n  }\n\n  /**\n   * Retrieve the last character of the last string sent to append.\n   */\n  abstract char getLastChar();\n\n  void addIdentifier(String identifier) {\n    add(identifier);\n  }\n\n  /**\n   * Appends a string to the code, keeping track of the current line length.\n   *\n   * NOTE: the string must be a complete token--partial strings or\n   * partial regexes will run the risk of being split across lines.\n   *\n   * Do not directly append newlines with this method. Instead use\n   * {@link #startNewLine}.\n   */\n  abstract void append(String str);\n\n  void appendBlockStart() {\n    append(\"{\");\n  }\n\n  void appendBlockEnd() {\n    append(\"}\");\n  }\n\n  void startNewLine() {\n  }\n\n  void maybeLineBreak() {\n    maybeCutLine();\n  }\n\n  void maybeCutLine() {\n  }\n\n  void endLine() {\n  }\n\n  void notePreferredLineBreak() {\n  }\n\n  void beginBlock() {\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n    }\n    appendBlockStart();\n\n    endLine();\n    statementNeedsEnded = false;\n  }\n\n  void endBlock() {\n    endBlock(false);\n  }\n\n  void endBlock(boolean shouldEndLine) {\n    appendBlockEnd();\n    if (shouldEndLine) {\n      endLine();\n    }\n    statementNeedsEnded = false;\n  }\n\n  void listSeparator() {\n    add(\",\");\n    maybeLineBreak();\n  }\n\n  /**\n   * Indicates the end of a statement and a ';' may need to be added.\n   * But we don't add it now, in case we're at the end of a block (in which\n   * case we don't have to add the ';').\n   * See maybeEndStatement()\n   */\n  void endStatement() {\n    endStatement(false);\n  }\n\n  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }\n\n  /**\n   * This is to be called when we're in a statement. If the prev statement\n   * needs to be ended, add a ';'.\n   */\n  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }\n\n  void endFunction() {\n    endFunction(false);\n  }\n\n  void endFunction(boolean statementContext) {\n    sawFunction = true;\n    if (statementContext) {\n      endLine();\n    }\n  }\n\n  void beginCaseBody() {\n    append(\":\");\n  }\n\n  void endCaseBody() {\n  }\n\n  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n",
    "label": "clean",
    "id": "91ea1f58-b7e1-46d1-96bd-73d1557ef1d6"
  },
  {
    "project": "Lang",
    "bug_id": "56",
    "file": "org/apache/commons/lang/time/FastDateFormat.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang.Validate;\n\n/**\n * <p>FastDateFormat is a fast and thread-safe version of\n * {@link java.text.SimpleDateFormat}.</p>\n * \n * <p>This class can be used as a direct replacement to\n * <code>SimpleDateFormat</code> in most formatting situations.\n * This class is especially useful in multi-threaded server environments.\n * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n * nor will it be as Sun have closed the bug/RFE.\n * </p>\n *\n * <p>Only formatting is supported, but all patterns are compatible with\n * SimpleDateFormat (except time zones - see below).</p>\n *\n * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent\n * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n * This pattern letter can be used here (on all JDK versions).</p>\n *\n * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent\n * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n * This introduces a minor incompatibility with Java 1.4, but at a gain of\n * useful functionality.</p>\n *\n * @author TeaTrove project\n * @author Brian S O'Neill\n * @author Sean Schofield\n * @author Gary Gregory\n * @author Stephen Colebourne\n * @author Nikolay Metchev\n * @since 2.0\n * @version $Id$\n */\npublic class FastDateFormat extends Format {\n    // A lot of the speed in this class comes from caching, but some comes\n    // from the special int to StringBuffer conversion.\n    //\n    // The following produces a padded 2 digit number:\n    //   buffer.append((char)(value / 10 + '0'));\n    //   buffer.append((char)(value % 10 + '0'));\n    //\n    // Note that the fastest append to StringBuffer is a single char (used here).\n    // Note that Integer.toString() is not called, the conversion is simply\n    // taking the value and adding (mathematically) the ASCII value for '0'.\n    // So, don't change this code! It works and is very fast.\n    \n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * FULL locale dependent date or time style.\n     */\n    public static final int FULL = DateFormat.FULL;\n    /**\n     * LONG locale dependent date or time style.\n     */\n    public static final int LONG = DateFormat.LONG;\n    /**\n     * MEDIUM locale dependent date or time style.\n     */\n    public static final int MEDIUM = DateFormat.MEDIUM;\n    /**\n     * SHORT locale dependent date or time style.\n     */\n    public static final int SHORT = DateFormat.SHORT;\n    \n    private static String cDefaultPattern;\n\n    private static Map cInstanceCache = new HashMap(7);\n    private static Map cDateInstanceCache = new HashMap(7);\n    private static Map cTimeInstanceCache = new HashMap(7);\n    private static Map cDateTimeInstanceCache = new HashMap(7);\n    private static Map cTimeZoneDisplayCache = new HashMap(7);\n\n    /**\n     * The pattern.\n     */\n    private final String mPattern;\n    /**\n     * The time zone.\n     */\n    private final TimeZone mTimeZone;\n    /**\n     * Whether the time zone overrides any on Calendars.\n     */\n    private final boolean mTimeZoneForced;\n    /**\n     * The locale.\n     */\n    private final Locale mLocale;\n    /**\n     * Whether the locale overrides the default.\n     */\n    private final boolean mLocaleForced;\n    /**\n     * The parsed rules.\n     */\n    private Rule[] mRules;\n    /**\n     * The estimated maximum length.\n     */\n    private int mMaxLengthEstimate;\n\n",
    "label": "buggy",
    "id": "07a4f282-de49-4436-ac7b-1211512f96ee"
  },
  {
    "project": "Closure",
    "bug_id": "115",
    "file": "com/google/javascript/jscomp/FunctionInjector.java",
    "snippet": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n",
    "label": "clean",
    "id": "117352cf-63c2-4f42-9740-9892c9bb9d09"
  },
  {
    "project": "Lang",
    "bug_id": "58",
    "file": "org/apache/commons/lang/math/NumberUtils.java",
    "snippet": "    /**\n     * <p>Convert a <code>String</code> to a <code>double</code>, returning a\n     * default value if the conversion fails.</p>\n     *\n     * <p>If the string <code>str</code> is <code>null</code>, the default\n     * value is returned.</p>\n     *\n     * <pre>\n     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d\n     *   NumberUtils.toDouble(\"\", 1.1d)     = 1.1d\n     *   NumberUtils.toDouble(\"1.5\", 0.0d)  = 1.5d\n     * </pre>\n     *\n     * @param str the string to convert, may be <code>null</code>\n     * @param defaultValue the default value\n     * @return the double represented by the string, or defaultValue\n     *  if conversion fails\n     * @since 2.1\n     */\n    public static double toDouble(String str, double defaultValue) {\n      if (str == null) {\n          return defaultValue;\n      }\n      try {\n          return Double.parseDouble(str);\n      } catch (NumberFormatException nfe) {\n          return defaultValue;\n      }\n    }\n\n    //-----------------------------------------------------------------------\n    // must handle Long, Float, Integer, Float, Short,\n    //                  BigDecimal, BigInteger and Byte\n    // useful methods:\n    // Byte.decode(String)\n    // Byte.valueOf(String,int radix)\n    // Byte.valueOf(String)\n    // Double.valueOf(String)\n    // Float.valueOf(String)\n    // new Float(String)\n    // Integer.valueOf(String,int radix)\n    // Integer.valueOf(String)\n    // Integer.decode(String)\n    // Integer.getInteger(String)\n    // Integer.getInteger(String,int val)\n    // Integer.getInteger(String,Integer val)\n    // new Integer(String)\n    // new Double(String)\n    // new Byte(String)\n    // new Long(String)\n    // Long.getLong(String)\n    // Long.getLong(String,int)\n    // Long.getLong(String,Integer)\n    // Long.valueOf(String,int)\n    // Long.valueOf(String)\n    // new Short(String)\n    // Short.decode(String)\n    // Short.valueOf(String,int)\n    // Short.valueOf(String)\n    // new BigDecimal(String)\n    // new BigInteger(String)\n    // new BigInteger(String,int radix)\n    // Possible inputs:\n    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n    // plus minus everything. Prolly more. A lot are not separable.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n",
    "label": "buggy",
    "id": "8445b96c-cf0d-44e6-a6ea-07936e442c19"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "99",
    "file": "com/fasterxml/jackson/databind/type/ReferenceType.java",
    "snippet": "    /**\n     * @since 2.7\n     */\n    public static ReferenceType construct(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType refType)\n    {\n        return new ReferenceType(cls, bindings, superClass, superInts,\n                refType, null, null, null, false);\n    }\n\n    @Deprecated // since 2.7\n    public static ReferenceType construct(Class<?> cls, JavaType refType) {\n        return new ReferenceType(cls, TypeBindings.emptyBindings(),\n                // !!! TODO: missing supertypes\n                null, null, null, refType, null, null, false);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_referencedType == contentType) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _anchorType, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withTypeHandler(Object h)\n    {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType, _anchorType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h)\n    {\n        if (h == _referencedType.<Object>getTypeHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withTypeHandler(h), _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                h, _typeHandler,_asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n        if (h == _referencedType.<Object>getValueHandler()) {\n            return this;\n        }\n        JavaType refdType = _referencedType.withValueHandler(h);\n        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n",
    "label": "buggy",
    "id": "848bf350-a520-4d8d-aaa4-20dab56b7529"
  },
  {
    "project": "Collections",
    "bug_id": "16",
    "file": "org/apache/commons/collections/list/SetUniqueList.java",
    "snippet": "    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos);  // remove the duplicate by index\n        }\n\n        set.add(object);      // add the new item to the unique set\n        set.remove(removed);  // remove the item deleted by the set\n\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n",
    "label": "buggy",
    "id": "96d3c2f5-8dd3-45c5-b5af-fdbece720613"
  },
  {
    "project": "Jsoup",
    "bug_id": "80",
    "file": "org/jsoup/parser/XmlTreeBuilder.java",
    "snippet": "/**\n * Use the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the\n * document.\n * <p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>\n *\n * @author Jonathan Hedley\n */\npublic class XmlTreeBuilder extends TreeBuilder {\n    ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                if (doc.childNodeSize() > 0) {\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n                } // else, we couldn't parse it as a decl, so leave as a comment\n            }\n",
    "label": "clean",
    "id": "55ebcc0e-473a-4ab1-b36f-fb488e9176d6"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "58",
    "file": "com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
    "snippet": "    /**\n     * Globally shareable thread-safe instance which has no additional custom deserializers\n     * registered\n     */\n    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(\n            new DeserializerFactoryConfig());\n\n    public BeanDeserializerFactory(DeserializerFactoryConfig config) {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional deserializers, or losing deserializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }\n    \n    /*\n    /**********************************************************\n    /* DeserializerFactory API implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException\n    {\n    \t// First: need a BeanDescription for builder class\n    \tJavaType builderType = ctxt.constructType(builderClass);\n    \tBeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n    \treturn buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }\n    \n    /**\n     * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n     * deserializer registered for given type.\n     */\n    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // note: we do NOT check for custom deserializers here, caller has already\n        // done that\n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        // Also: better ensure these are post-processable?\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n    \n    protected JavaType materializeAbstractType(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // May have multiple resolvers, call in precedence order until one returns non-null\n        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);\n            if (concrete != null) {\n                return concrete;\n            }\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Public construction method beyond DeserializerFactory API:\n    /* can be called from outside as well as overridden by\n    /* sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new NoClassDefFoundDeserializer<Object>(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        // [JACKSON-440]: update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        /* 19-Mar-2012, tatu: This check used to be done earlier; but we have to defer\n         *   it a bit to collect information on ObjectIdReader, for example.\n         */\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    /**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n    \t// Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n    \n    protected void addObjectIdReader(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        // also: unlike with value deserializers, let's just resolve one we need here\n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // Java 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for Bean deserializer construction,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Overridable method that constructs a {@link BeanDeserializerBuilder}\n     * which is used to accumulate information needed to create deserializer\n     * instance.\n     */\n    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt,\n            BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }\n    \n    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        \n        // Things specified as \"ok to ignore\"?\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n            if (B != null) {\n                builder.setIgnoreUnknownProperties(B.booleanValue());\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (isConcrete && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '%s' (in class %s)\",\n                            name, beanDesc.getBeanClass().getName());\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n    \n    /**\n     * Helper method called to filter out explicit ignored properties,\n     * as well as properties that have \"ignorable types\".\n     * Note that this will not remove properties that have no\n     * setters.\n     */\n    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder,\n            List<BeanPropertyDefinition> propDefsIn,\n            Set<String> ignored)\n        throws JsonMappingException\n    {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        // These are all valid setters, but we do need to introspect bit more\n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n                continue;\n            }\n            if (!property.hasConstructorParameter()) { // never skip constructor params\n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                // [JACKSON-429] Some types are declared as ignorable as well\n                if ((rawPropertyType != null)\n                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {\n                    // important: make ignorable, to avoid errors if value is actually seen\n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }\n\n    /**\n     * Method that will find if bean has any managed- or back-reference properties,\n     * and if so add them to bean, to be linked during resolution phase.\n     */\n    protected void addReferenceProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        // and then back references, not necessarily found as regular properties\n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                JavaType type;\n                if (m instanceof AnnotatedMethod) {\n                    type = ((AnnotatedMethod) m).getParameterType(0);\n                } else {\n                    type = m.getType();\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                \t\tctxt.getConfig(), m);\n                builder.addBackReferenceProperty(name, constructSettableProperty(\n                        ctxt, beanDesc, propDef, type));\n            }\n        }\n    }\n\n    /**\n     * Method called locate all members used for value injection (if any),\n     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n     */\n    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    m.fixAccess(forceAccess); // to ensure we can call it\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n\n    /**\n     * Method called to construct fallback {@link SettableAnyProperty}\n     * for handling unknown bean properties, given a method that\n     * has been designated as such setter.\n     */\n    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedMethod setter)\n        throws JsonMappingException\n    {\n        if (ctxt.canOverrideAccessModifiers()) {\n            setter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); // to ensure we can call it\n        }\n        // we know it's a 2-arg method, second arg is the value\n        JavaType type = setter.getParameterType(1);\n        BeanProperty.Std property = new BeanProperty.Std(PropertyName.construct(setter.getName()),\n                type, null, beanDesc.getClassAnnotations(), setter,\n                PropertyMetadata.STD_OPTIONAL);\n        type = resolveType(ctxt, beanDesc, type, setter);\n\n        /* AnySetter can be annotated with @JsonDeserialize (etc) just like a\n         * regular setter... so let's see if those are used.\n         * Returns null if no annotations, in which case binding will\n         * be done at a later point.\n         */\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter);\n        /* Otherwise, method may specify more specific (sub-)class for\n         * value (no need to check if explicit deser was specified):\n         */\n        type = modifyTypeByAnnotation(ctxt, setter, type);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(property, setter, type,\n                deser, typeDeser);\n    }\n\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n",
    "label": "buggy",
    "id": "60b84e32-9876-4aa0-afbc-b87bd3bbf826"
  },
  {
    "project": "JacksonXml",
    "bug_id": "6",
    "file": "com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java",
    "snippet": "    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamWriter getStaxWriter() {\n        return _xmlWriter;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, passing XML specific settings\n    /**********************************************************\n     */\n\n    public void setNextIsAttribute(boolean isAttribute)\n    {\n        _nextIsAttribute = isAttribute;\n    }\n\n    public void setNextIsUnwrapped(boolean isUnwrapped)\n    {\n        _nextIsUnwrapped = isUnwrapped;\n    }\n\n    public void setNextIsCData(boolean isCData)\n    {\n        _nextIsCData = isCData;\n    }\n    \n    public final void setNextName(QName name)\n    {\n        _nextName = name;\n    }\n\n    /**\n     * Method that does same as {@link #setNextName}, unless\n     * a name has already been set.\n     * \n     * @since 2.1.2\n     */\n    public final boolean setNextNameIfMissing(QName name)\n    {\n        if (_nextName == null) {\n            _nextName = name;\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Methdod called when a structured (collection, array, map) is being\n     * output.\n     * \n     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n     * @param wrappedName Element used around individual content items (can not\n     *   be null)\n     */\n    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeStartElement(_xmlWriter,\n                            wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                } else {\n                    _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n        this.setNextName(wrappedName);\n    }\n\n    /**\n     * Method called after a structured collection output has completed\n     */\n    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        // First: wrapper to close?\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeEndElement(_xmlWriter, _writeContext.getEntryCount());\n                } else {\n                    _xmlWriter.writeEndElement();\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n    }\n\n    /**\n     * Trivial helper method called when to add a replicated wrapper name\n     * \n     * @since 2.2\n     */\n    public void writeRepeatedFieldName() throws IOException\n    {\n        if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator method overrides\n    /**********************************************************\n     */\n    \n    /* Most overrides in this section are just to make methods final,\n     * to allow better inlining...\n     */\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        // Should this ever get called?\n        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n        setNextName(new QName(ns, name));\n    }\n    \n    @Override\n    public final void writeStringField(String fieldName, String value) throws IOException\n    {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    // 03-Aug-2017, tatu: We could use this as mentioned in comment below BUT\n    //    since there is no counterpart for deserialization this will not\n    //    help us. Approaches that could/would help probably require different\n    //    handling...\n    //\n    //    See [dataformat-xml#4] for more context.\n    \n    /*\n    // @since 2.9\n    public WritableTypeId writeTypePrefix(WritableTypeId typeIdDef) throws IOException\n    {\n        // 03-Aug-2017, tatu: Due to XML oddities, we do need to massage things\n        //     a bit: specifically, change WRAPPER_ARRAY into WRAPPER_OBJECT, always\n        if (typeIdDef.include == WritableTypeId.Inclusion.WRAPPER_ARRAY) {\n            typeIdDef.include = WritableTypeId.Inclusion.WRAPPER_OBJECT;\n        }\n        return super.writeTypePrefix(typeIdDef);\n    }\n    */\n\n    /*\n    /**********************************************************\n    /* JsonGenerator output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            // nothing to do here; no-operation\n        }\n    }\n    \n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not Array but \"+_writeContext.typeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            // nothing to do here; no-operation\n        }\n        _writeContext = _writeContext.getParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            _handleStartObject();\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n        }\n        _writeContext = _writeContext.getParent();\n        if (_cfgPrettyPrinter != null) {\n            // as per [Issue#45], need to suppress indentation if only attributes written:\n            int count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n            _cfgPrettyPrinter.writeEndObject(this, count);\n        } else {\n            _handleEndObject();\n        }\n    }\n\n    // note: public just because pretty printer needs to make a callback\n    public final void _handleStartObject() throws IOException\n    {\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        // Need to keep track of names to make Lists work correctly\n        _elementNameStack.addLast(_nextName);\n        try {\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    // note: public just because pretty printer needs to make a callback\n    public final void _handleEndObject() throws IOException\n    {\n        // We may want to repeat same element, so:\n        if (_elementNameStack.isEmpty()) {\n            throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n        }\n        _nextName = _elementNameStack.removeLast();\n        try {\n            // note: since attributes don't nest, can only have one attribute active, so:\n            _nextIsAttribute = false;\n            _xmlWriter.writeEndElement();\n            // [databind-xml#172]: possibly also need indentation\n            if (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n                // ... but only if it is likely to succeed:\n                if (!_stax2Emulation) {\n                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        writeFieldName(name.getValue());\n    }\n    \n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) { // must write attribute name and value with one call\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else if (checkNextIsUnwrapped()) {\n                // [Issue#56] Should figure out how to prevent indentation for end element\n                //   but for now, let's just make sure structure is correct\n                //if (_xmlPrettyPrinter != null) { ... }\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n                _xmlWriter.writeEndElement();\n            } \n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }    \n    \n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, offset, len, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text.substring(offset, offset + len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        _verifyValueWrite(\"write raw value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException\n    {\n        writeRaw(String.valueOf(c));\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n    \t\tbyte[] data, int offset, int len) throws IOException\n    {\n        if (data == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write Binary value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                // Stax2 API only has 'full buffer' write method:\n                byte[] fullBuffer = toFullBuffer(data, offset, len);\n                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeBinary(data, offset, len);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            data, offset, len);\n                } else {\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                    _xmlWriter.writeBinary(data, offset, len);\n                    _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n                // Stax2 API only has 'full buffer' write method:\n              // should we consider pretty-printing or not?\n\n\n\n",
    "label": "buggy",
    "id": "5f0812dd-3ecb-4366-a640-708d953112d8"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "104",
    "file": "com/fasterxml/jackson/databind/util/StdDateFormat.java",
    "snippet": "    /**\n     * Accessor for checking whether this instance would include colon\n     * within timezone serialization or not: if {code true}, timezone offset\n     * is serialized like {@code -06:00}; if {code false} as {@code -0600}.\n     *<p>\n     * NOTE: only relevant for serialization (formatting), as deserialization\n     * (parsing) always accepts optional colon but does not require it, regardless\n     * of this setting.\n     *\n     * @return {@code true} if a colon is to be inserted between the hours and minutes \n     * of the TZ offset when serializing as String; otherwise {@code false}\n     *\n     * @since 2.9.1\n     */\n    public boolean isColonIncludedInTimeZone() {\n        return _tzSerializedWithColon;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, parsing\n    /**********************************************************\n     */\n\n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date dt = _parseDate(dateStr, pos);\n        if (dt != null) {\n            return dt;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Cannot parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    // 24-Jun-2017, tatu: I don't think this ever gets called. So could... just not implement?\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        try {\n            return _parseDate(dateStr, pos);\n        } catch (ParseException e) {\n            // may look weird but this is what `DateFormat` suggest to do...\n        }\n        return null;\n    }\n\n    protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        // Also consider \"stringified\" simple time stamp\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if ((i < 0)\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n                && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n            return _parseDateFromLong(dateStr, pos);\n        }\n        // Otherwise, fall back to using RFC 1123. NOTE: call will NOT throw, just returns `null`\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, writing\n    /**********************************************************\n     */\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        TimeZone tz = _timezone;\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        _format(tz, _locale, date, toAppendTo);\n        return toAppendTo;\n    }\n    \n    protected void _format(TimeZone tz, Locale loc, Date date,\n            StringBuffer buffer)\n    {\n        Calendar cal = _getCalendar(tz);\n        cal.setTime(date);\n        // [databind#2167]: handle range beyond [1, 9999]\n        final int year = cal.get(Calendar.YEAR);\n\n        // Assuming GregorianCalendar, special handling needed for BCE (aka BC)\n                // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but\n                //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement\n                //   for max length would be needed, we ewould need to limit to arbitrary length\n                //   like five digits (erroring out if beyond or padding to that as minimum).\n                //   Instead, let's just print number out as is and let decoder try to make sense of it.\n",
    "label": "buggy",
    "id": "ee22dd8c-4606-4f4a-ae25-d02876c4a44a"
  },
  {
    "project": "Compress",
    "bug_id": "3",
    "file": "org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.tar;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\n\n/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    /** Fail if a long file name is required in the archive. */\n    public static final int LONGFILE_ERROR = 0;\n\n    /** Long paths will be truncated in the archive. */\n    public static final int LONGFILE_TRUNCATE = 1;\n\n    /** GNU tar extensions are used to store long file names in the archive. */\n    public static final int LONGFILE_GNU = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n\n    private boolean closed = false;\n\n    /* Indicates if putArchiveEntry has been called without closeArchiveEntry */\n    \n    private final OutputStream out;\n\n    /**\n     * Constructor for TarInputStream.\n",
    "label": "buggy",
    "id": "65d2bacd-0bb4-40d1-b2e3-7d5d4244ff2c"
  },
  {
    "project": "Mockito",
    "bug_id": "31",
    "file": "org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
    "snippet": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\n\nimport org.mockito.Mockito;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.exceptions.Reporter;\n",
    "label": "buggy",
    "id": "62eef398-2fa7-492f-9241-07339c89dd5b"
  },
  {
    "project": "Jsoup",
    "bug_id": "32",
    "file": "org/jsoup/nodes/Element.java",
    "snippet": "    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames();\n        return clone;\n    }\n}\n",
    "label": "buggy",
    "id": "34c71d90-0dda-4ded-9c91-7566f2607de9"
  },
  {
    "project": "Closure",
    "bug_id": "36",
    "file": "com/google/javascript/jscomp/InlineVariables.java",
    "snippet": "    /**\n     * Compute whether the given string is worth inlining.\n     */\n    private boolean isStringWorthInlining(Var var, List<Reference> refs) {\n      if (!inlineAllStrings && !var.isDefine()) {\n        int len = var.getInitialValue().getString().length() + \"''\".length();\n\n        // if not inlined: var xx=\"value\"; .. xx .. xx ..\n        // The 4 bytes per reference is just a heuristic:\n        // 2 bytes per var name plus maybe 2 bytes if we don't inline, e.g.\n        // in the case of \"foo \" + CONST + \" bar\"\n        int noInlineBytes = \"var xx=;\".length() + len +\n                            4 * (refs.size() - 1);\n\n        // if inlined:\n        // I'm going to assume that half of the quotes will be eliminated\n        // thanks to constant folding, therefore I subtract 1 (2/2=1) from\n        // the string length.\n        int inlineBytes = (len - 1) * (refs.size() - 1);\n\n        // Not inlining if doing so uses more bytes, or this constant is being\n        // defined.\n        return noInlineBytes >= inlineBytes;\n      }\n\n      return true;\n    }\n\n    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      // Do not inline into a call node. This would change\n      // the context in which it was being called. For example,\n      //   var a = b.c;\n      //   a();\n      // should not be inlined, because it calls a in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is ok.\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          // Bug 2388531: Don't inline subclass definitions into class defining\n          // calls as this confused class removing logic.\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n\n          // issue 668: Don't inline singleton getter methods\n          // calls as this confused class removing logic.\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n        }\n      }\n\n",
    "label": "clean",
    "id": "19eefb38-a789-4a19-935e-25bde6876a9c"
  },
  {
    "project": "Gson",
    "bug_id": "17",
    "file": "com/google/gson/DefaultDateTypeAdapter.java",
    "snippet": "/**\n * This type adapter supports three subclasses of date: Date, Timestamp, and\n * java.sql.Date.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n\n  private static final String SIMPLE_NAME = \"DefaultDateTypeAdapter\";\n\n  private final Class<? extends Date> dateType;\n  private final DateFormat enUsFormat;\n  private final DateFormat localFormat;\n  \n  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {\n    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {\n    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n  }\n\n  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\n    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\n      throw new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n    }\n    this.dateType = dateType;\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }\n\n  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n  // See issue 162\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    synchronized (localFormat) {\n      String dateFormatAsString = enUsFormat.format(value);\n      out.value(dateFormatAsString);\n    }\n  }\n\n  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n",
    "label": "buggy",
    "id": "29d6bc5a-ebae-4a1a-8ab5-98e82ae850f2"
  },
  {
    "project": "Jsoup",
    "bug_id": "62",
    "file": "org/jsoup/parser/HtmlTreeBuilderState.java",
    "snippet": "/**\n * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n */\nenum HtmlTreeBuilderState {\n    Initial {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; // ignore whitespace\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                // todo: parse error check on expected doctypes\n                // todo: quirk state check on doctype ids\n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                // todo: check not iframe srcdoc\n                tb.transition(BeforeHtml);\n                return tb.process(t); // re-process token\n            }\n            return true;\n        }\n    },\n    BeforeHtml {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; // ignore whitespace\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }\n    },\n    BeforeHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); // does not transition\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }\n    },\n    InHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        // jsoup special: update base the frist time it is seen\n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        // todo: charset switches\n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        // skips some script rules as won't execute them\n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }\n    },\n    InHeadNoscript {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }\n    },\n    AfterHead {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }\n\n        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }\n    },\n    InBody {\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        // same as final else, but short circuits lots of checks\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                // case will follow the original node (so honours ParseSettings)\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        // same as final fall through, but saves short circuit\n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n",
    "label": "buggy",
    "id": "5d1a9cc6-5f4e-475f-abbc-d60ae4eb8e9e"
  },
  {
    "project": "JacksonCore",
    "bug_id": "22",
    "file": "com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
    "snippet": "    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n",
    "label": "buggy",
    "id": "234b6453-d728-4dc4-95a2-c71c5bf6f735"
  },
  {
    "project": "Closure",
    "bug_id": "5",
    "file": "com/google/javascript/jscomp/InlineObjectLiterals.java",
    "snippet": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n",
    "label": "buggy",
    "id": "ed163bcb-d91a-4046-8fb7-ec0818c4f7e7"
  },
  {
    "project": "Lang",
    "bug_id": "20",
    "file": "org/apache/commons/lang3/StringUtils.java",
    "snippet": "    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, {@code null} if null array input\n     * @since 2.0\n     */\n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n",
    "label": "buggy",
    "id": "162dd41f-6e72-4185-901c-e73f963abce5"
  },
  {
    "project": "JacksonCore",
    "bug_id": "17",
    "file": "com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "snippet": "    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n\n",
    "label": "buggy",
    "id": "2071bf09-19b9-475a-b613-2100c9735b54"
  },
  {
    "project": "Math",
    "bug_id": "47",
    "file": "org/apache/commons/math/complex/Complex.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math.FieldElement;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.NotPositiveException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <br/>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul>\n * Note that this is in contradiction with the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link MathUtils#equals(double,double,int) equals for primitive double} in\n * {@link MathUtils} conforms with IEEE-754 while this class conforms with\n * the standard behavior for Java object types.\n * <br/>\n * Implements Serializable since 2.0\n *\n * @version $Id$\n */\npublic class Complex implements FieldElement<Complex>, Serializable  {\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n    /** The real part. */\n    private final double real;\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n    /** Record whether this complex number is zero. */\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param real Real part.\n",
    "label": "buggy",
    "id": "707bde08-5127-4adf-9c8c-9289dcac632b"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "112",
    "file": "com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java",
    "snippet": "    /**********************************************************\n     */\n    \n    public StringCollectionDeserializer(JavaType collectionType,\n            JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator)\n    {\n        this(collectionType, valueInstantiator, null, valueDeser, valueDeser, null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringCollectionDeserializer(JavaType collectionType,\n            ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser,\n            JsonDeserializer<?> valueDeser,\n            NullValueProvider nuller, Boolean unwrapSingle)\n    {\n        super(collectionType, nuller, unwrapSingle);\n        _valueDeserializer = (JsonDeserializer<String>) valueDeser;\n        _valueInstantiator = valueInstantiator;\n        _delegateDeserializer = (JsonDeserializer<Object>) delegateDeser;\n    }\n\n    protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser,\n            JsonDeserializer<?> valueDeser,\n            NullValueProvider nuller, Boolean unwrapSingle)\n    {\n        if ((_unwrapSingle == unwrapSingle) && (_nullProvider == nuller)\n                && (_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {\n            return this;\n        }\n        return new StringCollectionDeserializer(_containerType, _valueInstantiator,\n                delegateDeser, valueDeser, nuller, unwrapSingle);\n    }\n\n    @Override // since 2.5\n    public boolean isCachable() {\n        // 26-Mar-2015, tatu: Important: prevent caching if custom deserializers via annotations\n        //    are involved\n        return (_valueDeserializer == null) && (_delegateDeserializer == null);\n    }\n    \n    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n",
    "label": "buggy",
    "id": "4004aa7a-5d41-46ad-82a4-448a614c800a"
  },
  {
    "project": "Closure",
    "bug_id": "49",
    "file": "com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
    "snippet": "/**\n *  Find all Functions, VARs, and Exception names and make them\n *  unique.  Specifically, it will not modify object properties.\n *  @author johnlenz@google.com (John Lenz)\n *  TODO(johnlenz): Try to merge this with the ScopeCreator.\n */\nclass MakeDeclaredNamesUnique\n    implements NodeTraversal.ScopedCallback {\n\n  // Arguments is special cased to handle cases where a local name shadows\n  // the arguments declaration.\n  public static final String ARGUMENTS = \"arguments\";\n\n  // The name stack is similiar to how we model scopes but handles some\n  // additional cases that are not handled by the current Scope object.\n  // Specifically, a Scope currently has only two concepts of scope (global,\n  // and function local).  But there are in reality a couple of additional\n  // case to worry about:\n  //   catch expressions\n  //   function expressions names\n  // Both belong to a scope by themselves.\n  private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n  private final Renamer rootRenamer;\n\n  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }\n\n  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }\n\n  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {\n    return new ContextualRenameInverter(compiler);\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          declarationRoot.getType() != Token.FUNCTION ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (declarationRoot.getType() != Token.FUNCTION) {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n",
    "label": "clean",
    "id": "1b748700-057d-47d1-8037-f4c8ae00f57a"
  },
  {
    "project": "Closure",
    "bug_id": "7",
    "file": "com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
    "snippet": "    /**\n     * Computes whether the given result of a {@code typeof} operator matches\n     * expectations, i.e. whether a type that gives such a result should be\n     * kept.\n     */\n    private boolean matchesExpectation(String result) {\n      return result.equals(value) == resultEqualsValue;\n    }\n\n    @Override\n    protected JSType caseTopType(JSType topType) {\n      JSType result = topType;\n      if (resultEqualsValue) {\n        JSType typeByName = getNativeTypeForTypeOf(value);\n        if (typeByName != null) {\n          result = typeByName;\n        }\n      }\n      return result;\n    }\n\n    @Override\n    public JSType caseNoObjectType() {\n      return (value.equals(\"object\") || value.equals(\"function\")) ==\n          resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseBooleanType() {\n      return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n      return matchesExpectation(\"function\") ? type : null;\n    }\n\n    @Override\n    public JSType caseNullType() {\n      return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseNumberType() {\n      return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n    }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n          // Objects are restricted to \"Function\", subtypes are left\n          // Only filter out subtypes of \"function\"\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n",
    "label": "buggy",
    "id": "83a146bf-8a4a-4392-afa3-ef54f0d19ac1"
  },
  {
    "project": "Jsoup",
    "bug_id": "90",
    "file": "org/jsoup/helper/HttpConnection.java",
    "snippet": "    /**\n     * Encodes the input URL into a safe ASCII URL string\n     * @param url unescaped URL\n     * @return escaped URL\n     */\n\tprivate static String encodeUrl(String url) {\n        try {\n            URL u = new URL(url);\n            return encodeUrl(u).toExternalForm();\n        } catch (Exception e) {\n            return url;\n        }\n\t}\n\n    static URL encodeUrl(URL u) {\n        try {\n            //  odd way to encode urls, but it works!\n            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n            urlS = urlS.replaceAll(\" \", \"%20\");\n            final URI uri = new URI(urlS);\n            return new URL(uri.toASCIIString());\n        } catch (Exception e) {\n            return u;\n        }\n    }\n\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }\n\n    private Connection.Request req;\n    private Connection.Response res;\n\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }\n\n    public Connection proxy(Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }\n\n    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }\n\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }\n\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }\n\n    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    public Connection.KeyVal data(String key) {\n        Validate.notEmpty(key, \"Data key must not be empty\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }\n\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }\n\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNull(headers, \"Header map must not be null\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n        return req;\n    }\n\n    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }\n\n    public Connection.Response response() {\n        return res;\n    }\n\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> {\n        URL url;\n        Method method;\n        Map<String, List<String>> headers;\n        Map<String, String> cookies;\n\n        private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }\n\n        public URL url() {\n            return url;\n        }\n\n        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }\n\n        public Method method() {\n            return method;\n        }\n\n        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }\n\n        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }\n\n        @Override\n        public T addHeader(String name, String value) {\n            Validate.notEmpty(name);\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(fixHeaderEncoding(value));\n\n            return (T) this;\n        }\n\n        @Override\n        public List<String> headers(String name) {\n            Validate.notEmpty(name);\n            return getHeadersCaseInsensitive(name);\n        }\n\n        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // shouldn't happen as these both always exist\n                return val;\n            }\n        }\n\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n",
    "label": "clean",
    "id": "9661052d-c15c-47ba-87a6-3789e122fc7b"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "14",
    "file": "com/fasterxml/jackson/databind/ObjectReader.java",
    "snippet": "    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n            throws IOException, JsonProcessingException\n    {\n        return (T) _bindAsTree(jp);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; others similar to what ObjectMapper has\n    /**********************************************************\n     */\n    \n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(in));\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(r));\n    }\n\n    /**\n     * Method that reads content from given JSON input String,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(json));\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods; reading sequence of values\n    /**********************************************************\n     */\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n        // false -> do not close as caller gave parser instance\n        return _newIterator(_valueType, jp, ctxt,\n                _findRootDeserializer(ctxt, _valueType),\n                false, _valueToUpdate);\n    }\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _parserFactory.createParser(src);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _parserFactory.createParser(json);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of rest of ObjectCodec methods\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, data-binding\n    /**********************************************************\n     */\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(jp, ctxt);\n                } else {\n                    deser.deserialize(jp, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                if (valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                } else {\n                    result = valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                } else {\n                    if (valueToUpdate == null) {\n                        result = deser.deserialize(jp, ctxt);\n                    } else {\n                        deser.deserialize(jp, ctxt, valueToUpdate);\n                        result = valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n        try {\n            return _bindAsTree(jp);\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n",
    "label": "buggy",
    "id": "b3c6f6a0-8059-4ba9-9fcf-873ccd29efcd"
  },
  {
    "project": "Math",
    "bug_id": "26",
    "file": "org/apache/commons/math3/fraction/Fraction.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math3.fraction;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.util.FastMath;\n\n/**\n * Representation of a rational number.\n *\n * implements Serializable since 2.0\n *\n * @since 1.1\n * @version $Id$\n */\npublic class Fraction\n    extends Number\n    implements FieldElement<Fraction>, Comparable<Fraction>, Serializable {\n\n    /** A fraction representing \"2 / 1\". */\n    public static final Fraction TWO = new Fraction(2, 1);\n\n    /** A fraction representing \"1\". */\n    public static final Fraction ONE = new Fraction(1, 1);\n\n    /** A fraction representing \"0\". */\n    public static final Fraction ZERO = new Fraction(0, 1);\n\n    /** A fraction representing \"4/5\". */\n    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n    /** A fraction representing \"1/5\". */\n    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n\n    /** A fraction representing \"1/2\". */\n    public static final Fraction ONE_HALF = new Fraction(1, 2);\n\n    /** A fraction representing \"1/4\". */\n    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n\n    /** A fraction representing \"1/3\". */\n    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n\n    /** A fraction representing \"3/5\". */\n    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n\n    /** A fraction representing \"3/4\". */\n    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n\n    /** A fraction representing \"2/5\". */\n    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n\n    /** A fraction representing \"2/4\". */\n    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n\n    /** A fraction representing \"2/3\". */\n    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n\n    /** A fraction representing \"-1 / 1\". */\n    public static final Fraction MINUS_ONE = new Fraction(-1, 1);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 3698073679419233275L;\n\n    /** The denominator. */\n    private final int denominator;\n\n    /** The numerator. */\n    private final int numerator;\n\n    /**\n     * Create a fraction given the double value.\n     * @param value the double value to convert to a fraction.\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */\n    public Fraction(double value) throws FractionConversionException {\n        this(value, 1.0e-5, 100);\n    }\n\n    /**\n     * Create a fraction given the double value and maximum error allowed.\n     * <p>\n     * References:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n     * </ul>\n     * </p>\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */\n    public Fraction(double value, double epsilon, int maxIterations)\n        throws FractionConversionException\n    {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n\n    /**\n     * Create a fraction given the double value and maximum denominator.\n     * <p>\n     * References:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n     * </ul>\n     * </p>\n     * @param value the double value to convert to a fraction.\n     * @param maxDenominator The maximum allowed value for denominator\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge\n     */\n    public Fraction(double value, int maxDenominator)\n        throws FractionConversionException\n    {\n       this(value, 0, maxDenominator, 100);\n    }\n\n    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n",
    "label": "buggy",
    "id": "63d8c61a-f0d0-4aa4-a0c1-7e1ae8e13dd0"
  },
  {
    "project": "Closure",
    "bug_id": "25",
    "file": "com/google/javascript/jscomp/TypeInference.java",
    "snippet": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n    // TODO(user): Make the template logic more general.\n\n    if (fnType.getTemplateTypeName() == null) {\n      return;\n    }\n\n    int i = 0;\n    int childCount = n.getChildCount();\n    // Find the parameter whose type is the template type.\n    for (Node iParameter : fnType.getParameters()) {\n      JSType iParameterType =\n          getJSType(iParameter).restrictByNotNullOrUndefined();\n      if (iParameterType.isTemplateType()) {\n        // Find the actual type of this argument.\n        ObjectType iArgumentType = null;\n        if (i + 1 < childCount) {\n          Node iArgument = n.getChildAtIndex(i + 1);\n          iArgumentType = getJSType(iArgument)\n              .restrictByNotNullOrUndefined()\n              .collapseUnion()\n              .toObjectType();\n          if (iArgumentType == null) {\n            compiler.report(\n                JSError.make(NodeUtil.getSourceName(iArgument), iArgument,\n                    TEMPLATE_TYPE_NOT_OBJECT_TYPE,\n                    getJSType(iArgument).toString()));\n            return;\n          }\n        }\n\n        // Find the parameter whose type is function(this: T, ...)\n        boolean foundTemplateTypeOfThisParameter = false;\n        int j = 0;\n        for (Node jParameter : fnType.getParameters()) {\n          JSType jParameterType =\n              getJSType(jParameter).restrictByNotNullOrUndefined();\n          if (jParameterType.isFunctionType()) {\n            FunctionType jParameterFnType = jParameterType.toMaybeFunctionType();\n            if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n              foundTemplateTypeOfThisParameter = true;\n              // Find the actual type of the this argument.\n              if (j + 1 >= childCount) {\n                // TypeCheck#visitParameterList will warn so we bail.\n                return;\n              }\n              Node jArgument = n.getChildAtIndex(j + 1);\n              JSType jArgumentType = getJSType(jArgument);\n              if (jArgument.isFunction() &&\n                  jArgumentType.isFunctionType()) {\n                if (iArgumentType != null &&\n                    // null and undefined get filtered out above.\n                    !iArgumentType.isNoType()) {\n                  // If it's an function expression, update the type of this\n                  // using the actual type of T.\n                  FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType();\n                  if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n                    // The new type will be picked up when we traverse the inner\n                    // function.\n                    jArgument.setJSType(\n                        registry.createFunctionTypeWithNewThisType(\n                            jArgumentFnType, iArgumentType));\n                  }\n                } else {\n                  // Warn if the anonymous function literal references this.\n                  if (NodeUtil.referencesThis(\n                          NodeUtil.getFunctionBody(jArgument))) {\n                    compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n                        FUNCTION_LITERAL_UNDEFINED_THIS));\n                  }\n                }\n              }\n              // TODO(user): Add code to TypeCheck to check that the\n              // types of the arguments match.\n            }\n          }\n          j++;\n        }\n\n        if (!foundTemplateTypeOfThisParameter) {\n          compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n              TEMPLATE_TYPE_OF_THIS_EXPECTED));\n          return;\n        }\n      }\n      i++;\n    }\n  }\n\n  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n",
    "label": "buggy",
    "id": "dad76eb3-0698-4baf-8ca5-1dcf00692cee"
  },
  {
    "project": "JacksonCore",
    "bug_id": "15",
    "file": "com/fasterxml/jackson/core/filter/FilteringParserDelegate.java",
    "snippet": "    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n    \t\t//if not scalar and ended successfully, then return null\n    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n",
    "label": "clean",
    "id": "38276f79-f423-494f-9e8e-8332d834a946"
  },
  {
    "project": "Collections",
    "bug_id": "25",
    "file": "org/apache/commons/collections4/IteratorUtils.java",
    "snippet": "    /**\n     * Gets an iterator that iterates through a collections of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n        return new IteratorChain<E>(iterators);\n    }\n\n    // Collated\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code>.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n        return new CollatingIterator<E>(comp, iterator1, iterator2);\n    }\n\n    /**\n",
    "label": "clean",
    "id": "0b8c4e80-2467-48dc-909a-41d2ae3354f8"
  },
  {
    "project": "Jsoup",
    "bug_id": "24",
    "file": "org/jsoup/parser/TokeniserState.java",
    "snippet": "/**\n * States and transition activations for the Tokeniser.\n */\nenum TokeniserState {\n    Data {\n        // in data state, gather characters until a character reference or tag is found\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        // from & in data\n        void read(Tokeniser t, CharacterReader r) {\n            Character c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Data);\n        }\n    },\n    Rcdata {\n        /// handles data in title, textarea etc\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            Character c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(RawtextLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(ScriptDataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        // from < in data\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        // from < or </ in data, will have start or end tag pending\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            String tagName = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                // no default, as covered with above consumeToAny\n            }\n        }\n    },\n    RcdataLessthanSign {\n        // from < in rcdata\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(RawtextEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                }\n            } else\n                anythingElse(t, r);\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(ScriptDataEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptData);\n            }\n\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                r.advance();\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n",
    "label": "buggy",
    "id": "96307d3b-d29f-49c5-b3be-0dd7495ea17b"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "4",
    "file": "com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java",
    "snippet": "    /**\n     * Value serializer to use, if not the standard one (which is inlined)\n     */\n    protected JsonDeserializer<String> _elementDeserializer;\n\n    public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n\n        int ix = 0;\n        JsonToken t;\n\n        try {\n            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                // Ok: no need to convert Strings, but must recognize nulls\n                String value;\n                if (t == JsonToken.VALUE_STRING) {\n                    value = jp.getText();\n",
    "label": "clean",
    "id": "b7f5cb76-6807-4f90-93d5-67e64e886921"
  },
  {
    "project": "Closure",
    "bug_id": "1",
    "file": "com/google/javascript/jscomp/RemoveUnusedVars.java",
    "snippet": "  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    if (!removeGlobals) {\n      return;\n    }\n\n    Node function = fnScope.getRootNode();\n\n",
    "label": "clean",
    "id": "23fd8dfa-ef09-4732-8748-fefd182cff1b"
  },
  {
    "project": "Mockito",
    "bug_id": "38",
    "file": "org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
    "snippet": "    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }\n}\n",
    "label": "buggy",
    "id": "9097b840-31a1-40f9-9149-6f6c338c8d25"
  },
  {
    "project": "Compress",
    "bug_id": "2",
    "file": "org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.ar;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\n\n/**\n * Implements the \"ar\" archive format as an input stream.\n * \n * @NotThreadSafe\n * \n */\npublic class ArArchiveInputStream extends ArchiveInputStream {\n\n    private final InputStream input;\n    private long offset = 0;\n    private boolean closed;\n    /*\n     * If getNextEnxtry has been called, the entry metadata is stored in\n     * currentEntry.\n     */\n    private ArArchiveEntry currentEntry = null;\n    /*\n     * The offset where the current entry started. -1 if no entry has been\n     * called\n     */\n    private long entryOffset = -1;\n",
    "label": "clean",
    "id": "6aa3d496-991f-403e-9863-8dea5fb3007d"
  },
  {
    "project": "JacksonXml",
    "bug_id": "2",
    "file": "com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java",
    "snippet": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.XMLStreamLocation2;\nimport org.codehaus.stax2.XMLStreamReader2;\nimport org.codehaus.stax2.ri.Stax2ReaderAdapter;\n\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n * abstract out all irrelevant details, and to expose equivalent of flat token\n * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n * content) all of which is just to simplify\n * actual higher-level conversion to JSON tokens\n */\npublic class XmlTokenStream\n{\n    // // // main token states:\n    \n    public final static int XML_START_ELEMENT = 1;\n    public final static int XML_END_ELEMENT = 2;\n    public final static int XML_ATTRIBUTE_NAME = 3;\n    public final static int XML_ATTRIBUTE_VALUE = 4;\n    public final static int XML_TEXT = 5;\n    public final static int XML_END = 6;\n\n    // // // token replay states\n\n    private final static int REPLAY_START_DUP = 1;\n    private final static int REPLAY_END = 2;\n    private final static int REPLAY_START_DELAYED = 3;\n    \n    /*\n    /**********************************************************************\n    /* Configuration\n    /**********************************************************************\n     */\n\n    final protected XMLStreamReader2 _xmlReader;\n\n    final protected Object _sourceReference;\n    \n    /*\n    /**********************************************************************\n    /* Parsing state\n    /**********************************************************************\n     */\n\n    protected int _currentState;\n\n    protected int _attributeCount;\n\n    /**\n     * If true we have a START_ELEMENT with mixed text\n     *\n     * @since 2.8\n     */\n    protected boolean _mixedText;\n\n    /**\n     * Index of the next attribute of the current START_ELEMENT\n     * to return (as field name and value pair), if any; -1\n     * when no attributes to return\n",
    "label": "clean",
    "id": "84a98547-6cea-4171-99f8-ae80417c446a"
  },
  {
    "project": "Collections",
    "bug_id": "6",
    "file": "org/apache/commons/collections/map/Flat3Map.java",
    "snippet": "    /**\n     * Removes the specified mapping from this map.\n     * \n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n",
    "label": "buggy",
    "id": "86e84e7b-2035-44d9-b9fe-6379fc3fe115"
  },
  {
    "project": "Compress",
    "bug_id": "19",
    "file": "org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java",
    "snippet": "    /** {@inheritDoc} */\n    public byte[] getCentralDirectoryData() {\n        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n        int off = addSizes(data);\n        if (relativeHeaderOffset != null) {\n            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        if (diskStart != null) {\n            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n            off += WORD;\n        }\n        return data;\n    }\n\n    /** {@inheritDoc} */\n    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n        throws ZipException {\n        if (length == 0) {\n            // no local file data at all, may happen if an archive\n            // only holds a ZIP64 extended information extra field\n            // inside the central directory but not inside the local\n            // file header\n            return;\n        }\n        if (length < 2 * DWORD) {\n            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            remaining -= DWORD;\n        }\n        if (remaining >= WORD) {\n            diskStart = new ZipLong(buffer, offset);\n            offset += WORD;\n            remaining -= WORD;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                              int length)\n        throws ZipException {\n        // store for processing in reparseCentralDirectoryData\n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        // if there is no size information in here, we are screwed and\n        // can only hope things will get resolved by LFH data later\n        // But there are some cases that can be detected\n        // * all data is there\n        // * length == 24 -> both sizes and offset\n        // * length % 8 == 4 -> at least we can identify the diskStart field\n        if (length >= 3 * DWORD + WORD) {\n            parseFromLocalFileData(buffer, offset, length);\n        } else if (length == 3 * DWORD) {\n            size = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            compressedSize = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n        } else if (length % DWORD == WORD) {\n            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n",
    "label": "clean",
    "id": "ac5153cc-0451-46d8-ae64-c69d1ae60fdd"
  },
  {
    "project": "Jsoup",
    "bug_id": "10",
    "file": "org/jsoup/nodes/Node.java",
    "snippet": "    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n",
    "label": "buggy",
    "id": "a67c0bfd-f8c2-4b9d-ae50-d97119a9720a"
  },
  {
    "project": "Lang",
    "bug_id": "46",
    "file": "org/apache/commons/lang/StringEscapeUtils.java",
    "snippet": "    /**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false, false);\n    }\n\n    /**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules to\n     * a <code>Writer</code>.</p>\n",
    "label": "clean",
    "id": "41b0230e-0bcf-467c-a4c1-229ca7be9040"
  },
  {
    "project": "Math",
    "bug_id": "58",
    "file": "org/apache/commons/math/optimization/fitting/GaussianFitter.java",
    "snippet": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }\n\n    /**\n     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
    "label": "buggy",
    "id": "4e9cc0cf-25b4-4087-80d0-0115ba686084"
  },
  {
    "project": "Jsoup",
    "bug_id": "43",
    "file": "org/jsoup/nodes/Element.java",
    "snippet": "    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n",
    "label": "buggy",
    "id": "4b9167f0-f4a9-4f79-8610-f014d46a5429"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "108",
    "file": "com/fasterxml/jackson/databind/ObjectReader.java",
    "snippet": "    /**********************************************************\n     */\n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        // 05-Dec-2017, tatu: Important! Must clear \"valueToUpdate\" since we do not\n        //    want update to be applied here, as a side effect\n        ObjectReader codec = withValueToUpdate(null);\n        return new TreeTraversingParser((JsonNode) n, codec);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or {@code null} if no more content is accessible\n     * via passed {@link JsonParser}.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and all other methods that take input source: latter\n     * will return \"missing node\", NOT {@code null}\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }\n\n    @Override\n    public void writeTree(JsonGenerator g, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n",
    "label": "buggy",
    "id": "fa912a73-b2bc-4391-93a3-d04c98a881b2"
  },
  {
    "project": "Jsoup",
    "bug_id": "7",
    "file": "org/jsoup/nodes/Document.java",
    "snippet": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.Elements;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\n",
    "label": "clean",
    "id": "57defe96-569f-46db-8b33-57f9f6e822d2"
  },
  {
    "project": "JacksonCore",
    "bug_id": "14",
    "file": "com/fasterxml/jackson/core/io/IOContext.java",
    "snippet": "    /**********************************************************\n     */\n\n    protected final void _verifyAlloc(Object buffer) {\n        if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n    }\n\n    protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n    }\n\n    protected final void _verifyRelease(char[] toRelease, char[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n",
    "label": "buggy",
    "id": "02f874c8-06a3-4da0-9029-da4aa34e9a63"
  },
  {
    "project": "Closure",
    "bug_id": "99",
    "file": "com/google/javascript/jscomp/CheckGlobalThis.java",
    "snippet": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n",
    "label": "buggy",
    "id": "736f6c74-5b81-403c-bb73-7aaad1308e1e"
  },
  {
    "project": "Closure",
    "bug_id": "133",
    "file": "com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "snippet": "  /**\n   * Returns the remainder of the line.\n   */\n  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    return result;\n  }\n\n  /**\n   * Determines whether the parser has been populated with docinfo with a\n",
    "label": "buggy",
    "id": "17445f7c-a221-46a2-9b49-5eb7a943696f"
  },
  {
    "project": "Compress",
    "bug_id": "1",
    "file": "org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
    "snippet": "    /**\n     * Set a default header format. This will be used if no format is defined in\n     * the cpioEntry given to putNextEntry().\n     * \n     * @param format\n     *            A CPIO format\n     */\n    private void setFormat(final short format) {\n        switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown header type\");\n\n        }\n        synchronized (this) {\n            this.entryFormat = format;\n        }\n    }\n\n    /**\n     * Begins writing a new CPIO file entry and positions the stream to the\n     * start of the entry data. Closes the current entry if still active. The\n     * current time will be used if the entry has no set modification time and\n     * the default header format will be used if no other format is specified in\n     * the entry.\n     * \n     * @param e\n     *            the CPIO cpioEntry to be written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n        ensureOpen();\n        if (this.cpioEntry != null) {\n            closeArchiveEntry(); // close previous entry\n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        // TODO what happens if an entry has an other format than the\n        // outputstream?\n        if (e.getFormat() == -1) {\n            e.setFormat(this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.cpioEntry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(MAGIC_NEW.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(MAGIC_NEW_CRC.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(MAGIC_OLD_ASCII.getBytes());\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n    }\n\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.cpioEntry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.cpioEntry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n            pad(this.cpioEntry.getSize(), 4);\n        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n            pad(this.cpioEntry.getSize(), 2);\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            if (this.crc != this.cpioEntry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.cpioEntry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    /**\n     * Writes an array of bytes to the current CPIO entry data. This method will\n     * block until all the bytes are written.\n     * \n     * @param b\n     *            the data to be written\n     * @param off\n     *            the start offset in the data\n     * @param len\n     *            the number of bytes that are written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return;\n        }\n\n        if (this.cpioEntry == null) {\n            throw new IOException(\"no current CPIO entry\");\n        }\n        if (this.written + len > this.cpioEntry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n                this.crc += b[pos] & 0xFF;\n            }\n        }\n    }\n\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            super.close();\n            this.closed = true;\n        }\n    }\n\n",
    "label": "clean",
    "id": "30a1cb10-3278-411d-8861-393828637b89"
  },
  {
    "project": "Closure",
    "bug_id": "122",
    "file": "com/google/javascript/jscomp/parsing/IRFactory.java",
    "snippet": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n",
    "label": "buggy",
    "id": "db7f83a6-0e2a-4280-872e-33ac3a4f8951"
  },
  {
    "project": "Jsoup",
    "bug_id": "11",
    "file": "org/jsoup/select/Selector.java",
    "snippet": "    /**\n     Find elements matching selector.\n     @param query CSS selector\n     @param roots root elements to descend into\n     @return matching elements, empty if not\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n\n        for (Element root : roots) {\n            elements.addAll(select(query, root));\n        }\n        return new Elements(elements);\n    }\n\n    private Elements select() {\n        tq.consumeWhitespace();\n        \n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            elements.add(root);\n            combinator(tq.consume().toString());\n        } else {\n            addElements(findElements()); // chomp first element matcher off queue \n        }            \n               \n        while (!tq.isEmpty()) {\n",
    "label": "buggy",
    "id": "776b136f-f425-4d80-9ee5-79c04f676b51"
  },
  {
    "project": "Mockito",
    "bug_id": "18",
    "file": "org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
    "snippet": "/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = 1998191268711234347L;\n    ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n",
    "label": "buggy",
    "id": "f7a92cac-35e9-4417-af8c-64ae8b7b0ea8"
  },
  {
    "project": "Jsoup",
    "bug_id": "66",
    "file": "org/jsoup/nodes/Element.java",
    "snippet": "    /**\n     * Create a new Element from a tag and a base URI.\n     * \n     * @param tag element tag\n     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n     *            string, but not null.\n     * @see Tag#valueOf(String, ParseSettings)\n     */\n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n",
    "label": "clean",
    "id": "572efa10-f775-4382-99a7-2a730d3b33d7"
  },
  {
    "project": "Jsoup",
    "bug_id": "55",
    "file": "org/jsoup/parser/TokeniserState.java",
    "snippet": "/**\n * States and transition activations for the Tokeniser.\n */\nenum TokeniserState {\n    Data {\n        // in data state, gather characters until a character reference or tag is found\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        // from & in data\n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Data);\n        }\n    },\n    Rcdata {\n        /// handles data in title, textarea etc\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, RawtextLessthanSign);\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, ScriptDataLessthanSign);\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        // from < in data\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        // from < or </ in data, will have start or end tag pending\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                // no default, as covered with above consumeToAny\n            }\n        }\n    },\n    RcdataLessthanSign {\n        // from < in rcdata\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name);\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, RawtextEndTagName, Rawtext);\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, ScriptDataEndTagName, ScriptData);\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(r.current());\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        // from tagname <xxx\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        // from before attribute name\n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                // no default, as covered in consumeToAny\n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeValueUnquoted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                // no default, handled in consume to any above\n            }\n\n        }\n    },\n    // CharacterReferenceInAttributeValue state handled inline\n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n",
    "label": "clean",
    "id": "1cb2e38d-a1f7-4a2e-b4a0-f9d2a94d7b07"
  },
  {
    "project": "Math",
    "bug_id": "19",
    "file": "org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
    "snippet": "    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n",
    "label": "clean",
    "id": "53a298be-4c74-4244-baf6-36c81e9f3329"
  },
  {
    "project": "Jsoup",
    "bug_id": "85",
    "file": "org/jsoup/nodes/Attribute.java",
    "snippet": "    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
    "label": "clean",
    "id": "c88699e1-a351-4097-8e34-a6d219c4ee22"
  },
  {
    "project": "Math",
    "bug_id": "76",
    "file": "org/apache/commons/math/linear/SingularValueDecompositionImpl.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n/**\n * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n * orthogonal matrix). The size p depends on the chosen algorithm:\n * <ul>\n *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n *   <li>for compact SVD, p is the rank r of the matrix\n *       (i. e. the number of positive singular values),</li>\n *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n * </ul>\n * </p>\n * <p>\n * Note that since this class computes only the compact or truncated SVD and not\n * the full SVD, the singular values computed are always positive.\n * </p>\n *\n * @version $Revision$ $Date$\n * @since 2.0\n */\npublic class SingularValueDecompositionImpl implements SingularValueDecomposition {\n\n    /** Number of rows of the initial matrix. */\n    private int m;\n\n    /** Number of columns of the initial matrix. */\n    private int n;\n\n    /** Transformer to bidiagonal. */\n    private BiDiagonalTransformer transformer;\n\n    /** Main diagonal of the bidiagonal matrix. */\n    private double[] mainBidiagonal;\n\n    /** Secondary diagonal of the bidiagonal matrix. */\n    private double[] secondaryBidiagonal;\n\n    /** Main diagonal of the tridiagonal matrix. */\n    private double[] mainTridiagonal;\n\n    /** Secondary diagonal of the tridiagonal matrix. */\n    private double[] secondaryTridiagonal;\n\n    /** Eigen decomposition of the tridiagonal matrix. */\n    private EigenDecomposition eigenDecomposition;\n\n    /** Singular values. */\n    private double[] singularValues;\n\n    /** Cached value of U. */\n    private RealMatrix cachedU;\n\n    /** Cached value of U<sup>T</sup>. */\n    private RealMatrix cachedUt;\n\n    /** Cached value of S. */\n    private RealMatrix cachedS;\n\n    /** Cached value of V. */\n    private RealMatrix cachedV;\n\n    /** Cached value of V<sup>T</sup>. */\n    private RealMatrix cachedVt;\n\n    /**\n     * Calculates the compact Singular Value Decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public SingularValueDecompositionImpl(final RealMatrix matrix)\n        throws InvalidMatrixException {\n        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n    }\n\n    /**\n     * Calculates the Singular Value Decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @param max maximal number of singular values to compute\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n        throws InvalidMatrixException {\n\n        m = matrix.getRowDimension();\n        n = matrix.getColumnDimension();\n\n        cachedU  = null;\n        cachedS  = null;\n        cachedV  = null;\n        cachedVt = null;\n\n        // transform the matrix to bidiagonal\n        transformer         = new BiDiagonalTransformer(matrix);\n        mainBidiagonal      = transformer.getMainDiagonalRef();\n        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n\n        // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)\n        mainTridiagonal      = new double[mainBidiagonal.length];\n        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n        double a = mainBidiagonal[0];\n        mainTridiagonal[0] = a * a;\n        for (int i = 1; i < mainBidiagonal.length; ++i) {\n            final double b  = secondaryBidiagonal[i - 1];\n            secondaryTridiagonal[i - 1] = a * b;\n            a = mainBidiagonal[i];\n            mainTridiagonal[i] = a * a + b * b;\n        }\n\n        // compute singular values\n        eigenDecomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                       MathUtils.SAFE_MIN);\n        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n        int p = Math.min(max, eigenValues.length);\n        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n            --p;\n        }\n        singularValues = new double[p];\n        for (int i = 0; i < p; ++i) {\n            singularValues[i] = Math.sqrt(eigenValues[i]);\n        }\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n",
    "label": "buggy",
    "id": "7a98a306-2383-4ea8-9e72-9d9c4669113b"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "54",
    "file": "com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
    "snippet": "    /**********************************************************\n     */\n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n",
    "label": "clean",
    "id": "410092c9-bcf9-4ee6-9bd9-ec3c875d3f1b"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "9",
    "file": "com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java",
    "snippet": "/**\n * Specialized serializer that can be used as the generic key\n * serializer, when serializing {@link java.util.Map}s to JSON\n * Objects.\n */\n@SuppressWarnings(\"serial\")\npublic class StdKeySerializer extends StdSerializer<Object>\n{\n    public StdKeySerializer() { super(Object.class); }\n\n    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        \n        if (value instanceof Date) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else {\n",
    "label": "buggy",
    "id": "9a172baa-55f5-409d-8d6a-08dc6d0bf042"
  },
  {
    "project": "Jsoup",
    "bug_id": "77",
    "file": "org/jsoup/parser/XmlTreeBuilder.java",
    "snippet": "    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n",
    "label": "buggy",
    "id": "366b5445-480c-4405-9c86-7153b75d2976"
  },
  {
    "project": "Csv",
    "bug_id": "16",
    "file": "org/apache/commons/csv/CSVParser.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n",
    "label": "clean",
    "id": "445edca2-8681-443c-8b59-d72eb85a14a5"
  },
  {
    "project": "Math",
    "bug_id": "54",
    "file": "org/apache/commons/math/dfp/Dfp.java",
    "snippet": "    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n",
    "label": "buggy",
    "id": "ca6d2367-1264-4dbf-a496-89b42f6d9e83"
  },
  {
    "project": "Time",
    "bug_id": "22",
    "file": "org/joda/time/base/BasePeriod.java",
    "snippet": "    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        // bug [3264409]\n    }\n\n    /**\n     * Creates a period from the given millisecond duration, which is only really\n",
    "label": "buggy",
    "id": "317ad3aa-65f0-4e76-9617-749f033fbc4b"
  },
  {
    "project": "Lang",
    "bug_id": "42",
    "file": "org/apache/commons/lang/Entities.java",
    "snippet": "    /**\n     * <p>\n     * Escapes the characters in a <code>String</code>.\n     * </p>\n     * \n     * <p>\n     * For example, if you have called addEntity(&quot;foo&quot;, 0xA1), escape(&quot;\\u00A1&quot;) will return\n     * &quot;&amp;foo;&quot;\n     * </p>\n     * \n     * @param str\n     *            The <code>String</code> to escape.\n     * @return A new escaped <code>String</code>.\n     */\n    public String escape(String str) {\n        StringWriter stringWriter = createStringWriter(str);\n        try {\n            this.escape(stringWriter, str);\n        } catch (IOException e) {\n            // This should never happen because ALL the StringWriter methods called by #escape(Writer, String) do not\n            // throw IOExceptions.\n            throw new UnhandledException(e);\n        }\n        return stringWriter.toString();\n    }\n\n    /**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     * \n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n     *             methods.\n     * \n     * @see #escape(String)\n     * @see Writer\n     */\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n            String entityName = this.entityName(c);\n            if (entityName == null) {\n                if (c > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n",
    "label": "buggy",
    "id": "c45d1939-9bfa-4e64-a962-56bf376d782f"
  },
  {
    "project": "Closure",
    "bug_id": "115",
    "file": "com/google/javascript/jscomp/FunctionInjector.java",
    "snippet": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n",
    "label": "buggy",
    "id": "51998398-5d3b-48a6-a8e4-2b6601b3530c"
  },
  {
    "project": "JxPath",
    "bug_id": "2",
    "file": "org/apache/commons/jxpath/ri/compiler/Expression.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.util.ValueUtils;\n",
    "label": "buggy",
    "id": "7148bb26-2910-4c3f-9295-409b3b79c49c"
  },
  {
    "project": "JxPath",
    "bug_id": "15",
    "file": "org/apache/commons/jxpath/ri/axes/UnionContext.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.axes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n",
    "label": "clean",
    "id": "ba5c7a1e-3516-43f3-a9e7-134012d6e527"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "64",
    "file": "com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
    "snippet": "    /**********************************************************\n     */\n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n",
    "label": "clean",
    "id": "0cb4bb57-401b-43b1-abb6-cea06d4d9acb"
  },
  {
    "project": "Collections",
    "bug_id": "15",
    "file": "org/apache/commons/collections/list/SetUniqueList.java",
    "snippet": "    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos);  // remove the duplicate by index\n        }\n\n",
    "label": "clean",
    "id": "d41ca189-6a9e-4664-b1af-41110ad68811"
  },
  {
    "project": "Math",
    "bug_id": "74",
    "file": "org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
    "snippet": "  /** Set the safety factor for stepsize control.\n   * @param safety safety factor\n   */\n  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale;\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n",
    "label": "buggy",
    "id": "a629ff7b-86fd-49c2-bf92-4682ddc18649"
  },
  {
    "project": "Closure",
    "bug_id": "175",
    "file": "com/google/javascript/jscomp/FunctionInjector.java",
    "snippet": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n\n  private final AbstractCompiler compiler;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  private final Supplier<String> safeNameIdSupplier;\n\n  /**\n   * @param allowDecomposition Whether an effort should be made to break down\n   * expressions into simpler expressions to allow functions to be injected\n   * where they would otherwise be disallowed.\n",
    "label": "buggy",
    "id": "f037d226-bc3a-4cff-b203-b87bd90069a3"
  },
  {
    "project": "Math",
    "bug_id": "69",
    "file": "org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
    "snippet": "    /**\n     * Returns a matrix of standard errors associated with the estimates\n     * in the correlation matrix.<br/>\n     * <code>getCorrelationStandardErrors().getEntry(i,j)</code> is the standard\n     * error associated with <code>getCorrelationMatrix.getEntry(i,j)</code>\n     * <p>The formula used to compute the standard error is <br/>\n     * <code>SE<sub>r</sub> = ((1 - r<sup>2</sup>) / (n - 2))<sup>1/2</sup></code>\n     * where <code>r</code> is the estimated correlation coefficient and\n     * <code>n</code> is the number of observations in the source dataset.</p>\n     *\n     * @return matrix of correlation standard errors\n     */\n    public RealMatrix getCorrelationStandardErrors() {\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                double r = correlationMatrix.getEntry(i, j);\n                out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n\n    /**\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n",
    "label": "clean",
    "id": "2448760f-7e29-4ecc-8f15-f72bfbcef6fc"
  },
  {
    "project": "Collections",
    "bug_id": "11",
    "file": "org/apache/commons/collections/keyvalue/MultiKey.java",
    "snippet": "    /**\n     * Gets a debugging string version of the key.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        return \"MultiKey\" + Arrays.asList(keys).toString();\n    }\n\n\t/**\n\t * Calculate the hash code of the instance using the provided keys.\n\t * @param keys\n\t */\n\tprivate void calculateHashCode(Object[] keys)\n\t{\n\t\tint total = 0;\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] != null) {\n                total ^= keys[i].hashCode();\n            }\n        }\n        hashCode = total;\n\t}\n\t\n\t/**\n\t * Recalculate the hash code after deserialization. The hash code of some\n\t * keys might have change (hash codes based on the system hash code are\n\t * only stable for the same process). \n\t * @return the instance with recalculated hash code\n\t */\n}\n",
    "label": "buggy",
    "id": "beafd1c6-e511-471b-8980-984f0f6ba68e"
  },
  {
    "project": "Mockito",
    "bug_id": "32",
    "file": "org/mockito/internal/configuration/SpyAnnotationEngine.java",
    "snippet": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\n\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.Spy;\nimport org.mockito.configuration.AnnotationEngine;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.MockUtil;\n\n\n@SuppressWarnings({\"unchecked\"})\npublic class SpyAnnotationEngine implements AnnotationEngine {\n\n    public Object createMockFor(Annotation annotation, Field field) {\n",
    "label": "buggy",
    "id": "2f42ce31-e82a-4369-bd5c-f5b596a2a343"
  },
  {
    "project": "Csv",
    "bug_id": "10",
    "file": "org/apache/commons/csv/CSVPrinter.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    // ======================================================\n",
    "label": "clean",
    "id": "463a99be-1b95-4160-b0d2-80c08481ba17"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "102",
    "file": "com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
    "snippet": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.*;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\n\n@SuppressWarnings(\"serial\")\npublic abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    /**\n     * Flag that indicates that serialization must be done as the\n     * Java timestamp, regardless of other settings.\n     */\n    protected final Boolean _useTimestamp;\n\n    /**\n     * Specific format to use, if not default format: non null value\n     * also indicates that serialization is to be done as JSON String,\n     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n     */\n    protected final DateFormat _customFormat;\n\n    /**\n     * If {@link #_customFormat} is used, we will try to reuse instances in simplest\n     * possible form; thread-safe, but without overhead of <code>ThreadLocal</code>\n     * (not from code, but wrt retaining of possibly large number of format instances\n     * over all threads, properties with custom formats).\n     *\n     * @since 2.9\n     */\n    protected final AtomicReference<DateFormat> _reusedCustomFormat;\n\n    protected DateTimeSerializerBase(Class<T> type,\n            Boolean useTimestamp, DateFormat customFormat)\n    {\n        super(type);\n        _useTimestamp = useTimestamp;\n        _customFormat = customFormat;\n        _reusedCustomFormat = (customFormat == null) ? null : new AtomicReference<DateFormat>();\n    }\n\n    public abstract DateTimeSerializerBase<T> withFormat(Boolean timestamp, DateFormat customFormat);\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note! Should not skip if `property` null since that'd skip check\n        // for config overrides, in case of root value\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n",
    "label": "buggy",
    "id": "98f7aff6-3013-4f28-83f6-b8cbf8fb54c1"
  },
  {
    "project": "Lang",
    "bug_id": "35",
    "file": "org/apache/commons/lang3/ArrayUtils.java",
    "snippet": "    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            throw new IllegalArgumentException(\"Arguments cannot both be null\");            \n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n",
    "label": "clean",
    "id": "17dec0a9-99e2-42f8-a6e7-ac5e9524419d"
  },
  {
    "project": "Closure",
    "bug_id": "71",
    "file": "com/google/javascript/jscomp/CheckAccessControls.java",
    "snippet": "  /**\n   * Determines whether the given name is visible in the current context.\n   * @param t The current traversal.\n   * @param name The name node.\n   */\n  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        // If a name is private, make sure that we're in the same file.\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE &&\n            !t.getInput().getName().equals(docInfo.getSourceName())) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                  name.getString(), docInfo.getSourceName()));\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property with @const tag got reassigned\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n    // Check whether the property is modified\n    Node parent = getprop.getParent();\n    if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {\n      return;\n    }\n\n    ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    // Check whether constant properties are reassigned\n    if (objectType != null) {\n      ObjectType oType = objectType;\n      while (oType != null) {\n        if (oType.hasReferenceName()) {\n          if (initializedConstantProperties.containsEntry(\n                  oType.getReferenceName(), propertyName)) {\n            compiler.report(\n                t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,\n                    propertyName));\n            break;\n          }\n        }\n        oType = oType.getImplicitPrototype();\n      }\n\n      JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (info != null && info.isConstant()\n          && objectType.hasReferenceName()) {\n        initializedConstantProperties.put(objectType.getReferenceName(),\n            propertyName);\n      }\n\n      // Add the prototype when we're looking at an instance object\n      if (objectType.isInstanceType()) {\n        ObjectType prototype = objectType.getImplicitPrototype();\n        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n",
    "label": "buggy",
    "id": "fe8fad38-075d-4784-a64f-528f265222f1"
  },
  {
    "project": "Closure",
    "bug_id": "109",
    "file": "com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "snippet": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }\n\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n",
    "label": "buggy",
    "id": "08b2d036-c98c-4ce1-acbe-26fd84739ba9"
  },
  {
    "project": "Math",
    "bug_id": "10",
    "file": "org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
    "snippet": "    /** Get the array size required for holding partial derivatives data.\n     * <p>\n     * This number includes the single 0 order derivative element, which is\n     * guaranteed to be stored in the first element of the array.\n     * </p>\n     * @return array size required for holding partial derivatives data\n     */\n    public int getSize() {\n        return sizes[parameters][order];\n    }\n\n    /** Compute linear combination.\n     * The derivative structure built will be a1 * ds1 + a2 * ds2\n     * @param a1 first scale factor\n     * @param c1 first base (unscaled) component\n     * @param offset1 offset of first operand in its array\n     * @param a2 second scale factor\n     * @param c2 second base (unscaled) component\n     * @param offset2 offset of second operand in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void linearCombination(final double a1, final double[] c1, final int offset1,\n                                  final double a2, final double[] c2, final int offset2,\n                                  final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);\n        }\n    }\n\n    /** Compute linear combination.\n     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4\n     * @param a1 first scale factor\n     * @param c1 first base (unscaled) component\n     * @param offset1 offset of first operand in its array\n     * @param a2 second scale factor\n     * @param c2 second base (unscaled) component\n     * @param offset2 offset of second operand in its array\n     * @param a3 third scale factor\n     * @param c3 third base (unscaled) component\n     * @param offset3 offset of third operand in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void linearCombination(final double a1, final double[] c1, final int offset1,\n                                  final double a2, final double[] c2, final int offset2,\n                                  final double a3, final double[] c3, final int offset3,\n                                  final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i]);\n        }\n    }\n\n    /** Compute linear combination.\n     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4\n     * @param a1 first scale factor\n     * @param c1 first base (unscaled) component\n     * @param offset1 offset of first operand in its array\n     * @param a2 second scale factor\n     * @param c2 second base (unscaled) component\n     * @param offset2 offset of second operand in its array\n     * @param a3 third scale factor\n     * @param c3 third base (unscaled) component\n     * @param offset3 offset of third operand in its array\n     * @param a4 fourth scale factor\n     * @param c4 fourth base (unscaled) component\n     * @param offset4 offset of fourth operand in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void linearCombination(final double a1, final double[] c1, final int offset1,\n                                  final double a2, final double[] c2, final int offset2,\n                                  final double a3, final double[] c3, final int offset3,\n                                  final double a4, final double[] c4, final int offset4,\n                                  final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] =\n                    MathArrays.linearCombination(a1, c1[offset1 + i],\n                                                 a2, c2[offset2 + i],\n                                                 a3, c3[offset3 + i],\n                                                 a4, c4[offset4 + i]);\n        }\n    }\n\n    /** Perform addition of two derivative structures.\n     * @param lhs array holding left hand side of addition\n     * @param lhsOffset offset of the left hand side in its array\n     * @param rhs array right hand side of addition\n     * @param rhsOffset offset of the right hand side in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void add(final double[] lhs, final int lhsOffset,\n                    final double[] rhs, final int rhsOffset,\n                    final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];\n        }\n    }\n    /** Perform subtraction of two derivative structures.\n     * @param lhs array holding left hand side of subtraction\n     * @param lhsOffset offset of the left hand side in its array\n     * @param rhs array right hand side of subtraction\n     * @param rhsOffset offset of the right hand side in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void subtract(final double[] lhs, final int lhsOffset,\n                         final double[] rhs, final int rhsOffset,\n                         final double[] result, final int resultOffset) {\n        for (int i = 0; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i];\n        }\n    }\n\n    /** Perform multiplication of two derivative structures.\n     * @param lhs array holding left hand side of multiplication\n     * @param lhsOffset offset of the left hand side in its array\n     * @param rhs array right hand side of multiplication\n     * @param rhsOffset offset of the right hand side in its array\n     * @param result array where result must be stored (for\n     * multiplication the result array <em>cannot</em> be one of\n     * the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void multiply(final double[] lhs, final int lhsOffset,\n                         final double[] rhs, final int rhsOffset,\n                         final double[] result, final int resultOffset) {\n        for (int i = 0; i < multIndirection.length; ++i) {\n            final int[][] mappingI = multIndirection[i];\n            double r = 0;\n            for (int j = 0; j < mappingI.length; ++j) {\n                r += mappingI[j][0] *\n                     lhs[lhsOffset + mappingI[j][1]] *\n                     rhs[rhsOffset + mappingI[j][2]];\n            }\n            result[resultOffset + i] = r;\n        }\n    }\n\n    /** Perform division of two derivative structures.\n     * @param lhs array holding left hand side of division\n     * @param lhsOffset offset of the left hand side in its array\n     * @param rhs array right hand side of division\n     * @param rhsOffset offset of the right hand side in its array\n     * @param result array where result must be stored (for\n     * division the result array <em>cannot</em> be one of\n     * the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void divide(final double[] lhs, final int lhsOffset,\n                       final double[] rhs, final int rhsOffset,\n                       final double[] result, final int resultOffset) {\n        final double[] reciprocal = new double[getSize()];\n        pow(rhs, lhsOffset, -1, reciprocal, 0);\n        multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);\n    }\n\n    /** Perform remainder of two derivative structures.\n     * @param lhs array holding left hand side of remainder\n     * @param lhsOffset offset of the left hand side in its array\n     * @param rhs array right hand side of remainder\n     * @param rhsOffset offset of the right hand side in its array\n     * @param result array where result must be stored (it may be\n     * one of the input arrays)\n     * @param resultOffset offset of the result in its array\n     */\n    public void remainder(final double[] lhs, final int lhsOffset,\n                          final double[] rhs, final int rhsOffset,\n                          final double[] result, final int resultOffset) {\n\n        // compute k such that lhs % rhs = lhs - k rhs\n        final double rem = lhs[lhsOffset] % rhs[rhsOffset];\n        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);\n\n        // set up value\n        result[resultOffset] = rem;\n\n        // set up partial derivatives\n        for (int i = 1; i < getSize(); ++i) {\n            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];\n        }\n\n    }\n\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute power of a derivative structure.\n     * @param x array holding the base\n     * @param xOffset offset of the base in its array\n     * @param y array holding the exponent\n     * @param yOffset offset of the exponent in its array\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] x, final int xOffset,\n                    final double[] y, final int yOffset,\n                    final double[] result, final int resultOffset) {\n        final double[] logX = new double[getSize()];\n        log(x, xOffset, logX, 0);\n        final double[] yLogX = new double[getSize()];\n        multiply(logX, 0, y, yOffset, yLogX, 0);\n        exp(yLogX, 0, result, resultOffset);\n    }\n\n    /** Compute n<sup>th</sup> root of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n order of the root\n     * @param result array where result must be stored (for\n     * n<sup>th</sup> root the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void rootN(final double[] operand, final int operandOffset, final int n,\n                      final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]\n        double[] function = new double[1 + order];\n        double xk;\n        if (n == 2) {\n            function[0] = FastMath.sqrt(operand[operandOffset]);\n            xk          = 0.5 / function[0];\n        } else if (n == 3) {\n            function[0] = FastMath.cbrt(operand[operandOffset]);\n            xk          = 1.0 / (3.0 * function[0] * function[0]);\n        } else {\n            function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);\n            xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));\n        }\n        final double nReciprocal = 1.0 / n;\n        final double xReciprocal = 1.0 / operand[operandOffset];\n        for (int i = 1; i <= order; ++i) {\n            function[i] = xk;\n            xk *= xReciprocal * (nReciprocal - i);\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute exponential of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * exponential the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void exp(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        Arrays.fill(function, FastMath.exp(operand[operandOffset]));\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute exp(x) - 1 of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * exponential the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void expm1(final double[] operand, final int operandOffset,\n                      final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.expm1(operand[operandOffset]);\n        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute natural logarithm of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * logarithm the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void log(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.log(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Computes shifted logarithm of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * shifted logarithm the result array <em>cannot</em> be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void log1p(final double[] operand, final int operandOffset,\n                      final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.log1p(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / (1.0 + operand[operandOffset]);\n            double xk  = inv;\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Computes base 10 logarithm of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * base 10 logarithm the result array <em>cannot</em> be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void log10(final double[] operand, final int operandOffset,\n                      final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.log10(operand[operandOffset]);\n        if (order > 0) {\n            double inv = 1.0 / operand[operandOffset];\n            double xk  = inv / FastMath.log(10.0);\n            for (int i = 1; i <= order; ++i) {\n                function[i] = xk;\n                xk *= -i * inv;\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute cosine of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * cosine the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void cos(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.cos(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = -FastMath.sin(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute sine of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * sine the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void sin(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        function[0] = FastMath.sin(operand[operandOffset]);\n        if (order > 0) {\n            function[1] = FastMath.cos(operand[operandOffset]);\n            for (int i = 2; i <= order; ++i) {\n                function[i] = -function[i - 2];\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute tangent of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * tangent the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute arc cosine of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * arc cosine the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void acos(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acos(x);\n        if (order > 0) {\n            // the nth order derivative of acos has the form:\n            // dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = -1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute arc sine of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * arc sine the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void asin(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.asin(x);\n        if (order > 0) {\n            // the nth order derivative of asin has the form:\n            // dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 - x2);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (n - 1) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute arc tangent of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param result array where result must be stored (for\n     * arc tangent the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void atan(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.atan(x);\n        if (order > 0) {\n            // the nth order derivative of atan has the form:\n            // dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n\n            // where Q_n(x) is a degree n-1 polynomial with same parity as n-1\n            // Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ...\n            // the general recurrence relation for Q_n is:\n            // Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array\n            final double[] q = new double[order];\n            q[0] = 1;\n            final double x2    = x * x;\n            final double f     = 1.0 / (1 + x2);\n            double coeff = f;\n            function[1] = coeff * q[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial Q_n(x)\n                double v = 0;\n                q[n - 1] = -n * q[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + q[k];\n                    if (k > 2) {\n                        q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];\n                    } else if (k == 2) {\n                        q[0] = q[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n\n    /** Compute two arguments arc tangent of a derivative structure.\n     * @param y array holding the first operand\n     * @param yOffset offset of the first operand in its array\n     * @param x array holding the second operand\n     * @param xOffset offset of the second operand in its array\n     * @param result array where result must be stored (for\n     * two arguments arc tangent the result array <em>cannot</em>\n     * be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset) {\n\n        // compute r = sqrt(x^2+y^2)\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n        if (x[xOffset] >= 0) {\n\n            // compute atan2(y, x) = 2 atan(y / (r + x))\n            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n            }\n\n        } else {\n\n            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n            }\n\n        }\n\n        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n\n    }\n\n    /** Compute hyperbolic cosine of a derivative structure.\n     * @param operand array holding the operand\n",
    "label": "clean",
    "id": "4a052325-3587-4436-b7da-b5f025dea5cd"
  },
  {
    "project": "Closure",
    "bug_id": "2",
    "file": "com/google/javascript/jscomp/TypeCheck.java",
    "snippet": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n\n  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n",
    "label": "clean",
    "id": "35dcd206-8daf-4ed6-bd26-cc0c808655ab"
  },
  {
    "project": "Math",
    "bug_id": "104",
    "file": "org/apache/commons/math/special/Gamma.java",
    "snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.special;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.util.ContinuedFraction;\n\n/**\n * This is a utility class that provides computation methods related to the\n * Gamma family of functions.\n *\n * @version $Revision$ $Date$\n */\npublic class Gamma implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6587513359895466954L;\n\n    /** Maximum allowed numerical error. */\n    private static final double DEFAULT_EPSILON = 10e-9;\n\n    /** Lanczos coefficients */\n    private static double[] lanczos =\n    {\n        0.99999999999999709182,\n",
    "label": "buggy",
    "id": "3919afca-4e9f-4c37-8eb0-d920eff36f19"
  },
  {
    "project": "JacksonXml",
    "bug_id": "5",
    "file": "com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java",
    "snippet": "    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n",
    "label": "buggy",
    "id": "6a05c787-9cf5-4f3b-8c82-c00b58d5503c"
  },
  {
    "project": "Closure",
    "bug_id": "55",
    "file": "com/google/javascript/jscomp/FunctionRewriter.java",
    "snippet": "  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer) {\n    Node root = compiler.parseSyntheticCode(\n        reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n    return (root != null) ? root.removeFirstChild() : null;\n  }\n\n  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n  }\n\n  /**\n   * Information needed to apply a reduction.\n   */\n",
    "label": "buggy",
    "id": "7e7925ea-e546-4b7e-88c8-b97aee5ec9eb"
  },
  {
    "project": "JacksonCore",
    "bug_id": "4",
    "file": "com/fasterxml/jackson/core/util/TextBuffer.java",
    "snippet": "    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        // but above intended maximum, slow to increase by 25%\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n",
    "label": "clean",
    "id": "cdb49f36-2cfb-40ae-9c54-104a8987c82a"
  },
  {
    "project": "Compress",
    "bug_id": "31",
    "file": "org/apache/commons/compress/archivers/tar/TarUtils.java",
    "snippet": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte == 0) {\n                break;\n            }\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n",
    "label": "buggy",
    "id": "532d0327-dbb5-448a-85b7-ad35b5372c6a"
  },
  {
    "project": "Jsoup",
    "bug_id": "72",
    "file": "org/jsoup/parser/CharacterReader.java",
    "snippet": "    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n",
    "label": "clean",
    "id": "c6a76275-a764-4bde-bc26-4eb6e60457db"
  },
  {
    "project": "Closure",
    "bug_id": "62",
    "file": "com/google/javascript/jscomp/LightweightMessageFormatter.java",
    "snippet": "  /**\n   * A constructor for when the client doesn't care about source information.\n   */\n  private LightweightMessageFormatter() {\n    super(null);\n    this.excerpt = LINE;\n  }\n\n  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }\n\n  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }\n\n  static LightweightMessageFormatter withoutSource() {\n    return new LightweightMessageFormatter();\n  }\n\n  public String formatError(JSError error) {\n    return format(error, false);\n  }\n\n  public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }\n\n  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n",
    "label": "buggy",
    "id": "3f337cf4-7b77-489f-8c95-c930a4e73f41"
  },
  {
    "project": "Closure",
    "bug_id": "100",
    "file": "com/google/javascript/jscomp/CheckGlobalThis.java",
    "snippet": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n",
    "label": "clean",
    "id": "9001be49-3543-419b-801a-6102dc84fdde"
  },
  {
    "project": "Compress",
    "bug_id": "40",
    "file": "org/apache/commons/compress/utils/BitInputStream.java",
    "snippet": "    /**\n     * Clears the cache of bits that have been read from the\n     * underlying stream but not yet provided via {@link #readBits}.\n     */\n    public void clearBitCache() {\n        bitsCached = 0;\n        bitsCachedSize = 0;\n    }\n    \n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n",
    "label": "buggy",
    "id": "37acc1e9-9e9c-45b3-a40c-580c0383bd86"
  },
  {
    "project": "Cli",
    "bug_id": "17",
    "file": "org/apache/commons/cli/PosixParser.java",
    "snippet": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n",
    "label": "buggy",
    "id": "236655a6-44c6-4978-b04e-5864fca9732c"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "26",
    "file": "com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java",
    "snippet": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.SerializableString;\nimport com.fasterxml.jackson.core.io.SerializedString;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\n@JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\npublic class BeanPropertyWriter extends PropertyWriter\n    implements BeanProperty,\n        java.io.Serializable // since 2.6.2\n{\n    // as of 2.6.2\n    private static final long serialVersionUID = 4603296144163950020L;\n\n",
    "label": "clean",
    "id": "830fb1bb-1d30-4f8b-b549-ebafe1d2fbeb"
  },
  {
    "project": "Lang",
    "bug_id": "3",
    "file": "org/apache/commons/lang3/math/NumberUtils.java",
    "snippet": "    /**\n     * <p>Convert a <code>String</code> to an <code>short</code>, returning a\n     * default value if the conversion fails.</p>\n     *\n     * <p>If the string is <code>null</code>, the default value is returned.</p>\n     *\n     * <pre>\n     *   NumberUtils.toShort(null, 1) = 1\n     *   NumberUtils.toShort(\"\", 1)   = 1\n     *   NumberUtils.toShort(\"1\", 0)  = 1\n     * </pre>\n     *\n     * @param str  the string to convert, may be null\n     * @param defaultValue  the default value\n     * @return the short represented by the string, or the default if conversion fails\n     * @since 2.5\n     */\n    public static short toShort(final String str, final short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (final NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    // must handle Long, Float, Integer, Float, Short,\n    //                  BigDecimal, BigInteger and Byte\n    // useful methods:\n    // Byte.decode(String)\n    // Byte.valueOf(String,int radix)\n    // Byte.valueOf(String)\n    // Double.valueOf(String)\n    // Float.valueOf(String)\n    // Float.valueOf(String)\n    // Integer.valueOf(String,int radix)\n    // Integer.valueOf(String)\n    // Integer.decode(String)\n    // Integer.getInteger(String)\n    // Integer.getInteger(String,int val)\n    // Integer.getInteger(String,Integer val)\n    // Integer.valueOf(String)\n    // Double.valueOf(String)\n    // new Byte(String)\n    // Long.valueOf(String)\n    // Long.getLong(String)\n    // Long.getLong(String,int)\n    // Long.getLong(String,Integer)\n    // Long.valueOf(String,int)\n    // Long.valueOf(String)\n    // Short.valueOf(String)\n    // Short.decode(String)\n    // Short.valueOf(String,int)\n    // Short.valueOf(String)\n    // new BigDecimal(String)\n    // new BigInteger(String)\n    // new BigInteger(String,int radix)\n    // Possible inputs:\n    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n    // plus minus everything. Prolly more. A lot are not separable.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n",
    "label": "clean",
    "id": "3bd5dc4d-16ca-41c3-9131-dd0aeba8d881"
  },
  {
    "project": "Mockito",
    "bug_id": "6",
    "file": "org/mockito/Matchers.java",
    "snippet": "    /**\n     * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean() {\n        return reportMatcher(Any.ANY).returnFalse();\n    }\n\n    /**\n     * Any <code>byte</code>, <code>Byte</code> or <code>null</code>.\n     * <p>\n",
    "label": "buggy",
    "id": "d83cfaac-a85b-4542-8405-00004a4e03f7"
  },
  {
    "project": "JacksonCore",
    "bug_id": "17",
    "file": "com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "snippet": "    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            _writeRawSegment(buf, 0, len);\n            return;\n        }\n\n",
    "label": "clean",
    "id": "a30b92f3-af08-421c-a828-b68e1e667d88"
  },
  {
    "project": "Closure",
    "bug_id": "94",
    "file": "com/google/javascript/jscomp/NodeUtil.java",
    "snippet": "  /** the set of builtin constructors that don't have side effects. */\n  private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =\n      new HashSet<String>(Arrays.asList(\n        \"Array\",\n        \"Date\",\n        \"Error\",\n        \"Object\",\n        \"RegExp\",\n        \"XMLHttpRequest\"));\n\n  // Utility class; do not instantiate.\n  private NodeUtil() {}\n\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getExpressionBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getExpressionBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getExpressionBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      default:\n        return getBooleanValue(n);\n    }\n  }\n\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NULL:\n      case Token.FALSE:\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n\n\n  /**\n   * Gets the value of a node as a String, or null if it cannot be converted.\n   * When it returns a non-null String, this method effectively emulates the\n   * <code>String()</code> JavaScript cast function.\n   */\n  static String getStringValue(Node n) {\n    // TODO(user): Convert constant array, object, and regex literals as well.\n    switch (n.getType()) {\n      case Token.NAME:\n      case Token.STRING:\n        return n.getString();\n\n      case Token.NUMBER:\n        double value = n.getDouble();\n        long longValue = (long) value;\n\n        // Return \"1\" instead of \"1.0\"\n        if (longValue == value) {\n          return Long.toString(longValue);\n        } else {\n          return Double.toString(n.getDouble());\n        }\n\n      case Token.FALSE:\n      case Token.TRUE:\n      case Token.NULL:\n        return Node.tokenToName(n.getType());\n\n      case Token.VOID:\n        return \"undefined\";\n    }\n    return null;\n  }\n\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n) {\n    Node parent = n.getParent();\n    String name = n.getFirstChild().getString();\n    switch (parent.getType()) {\n      case Token.NAME:\n        // var name = function() ...\n        // var name2 = function name1() ...\n        return parent.getString();\n\n      case Token.ASSIGN:\n        // qualified.name = function() ...\n        // qualified.name2 = function name1() ...\n        return parent.getFirstChild().getQualifiedName();\n\n      default:\n        // function name() ...\n        return name != null && name.length() != 0 ? name : null;\n    }\n  }\n\n  /**\n   * Gets the function's name. This method recognizes the forms:\n   * <ul>\n   * <li>{@code {'name': function() ...}}</li>\n   * <li>{@code {name: function() ...}}</li>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getNearestFunctionName(Node n) {\n    String name = getFunctionName(n);\n    if (name != null) {\n      return name;\n    }\n\n    // Check for the form { 'x' : function() { } }\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.OBJECTLIT:\n        // Return the name of the literal's key.\n        return getStringValue(parent.getFirstChild());\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Returns true if this is an immutable value.\n   */\n  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() { return a; }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured vairables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   */\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }\n\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n",
    "label": "clean",
    "id": "34740209-174a-4b48-b5c1-48f161c4d5f7"
  },
  {
    "project": "JacksonXml",
    "bug_id": "3",
    "file": "com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java",
    "snippet": "    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\n            if (_nextToken == JsonToken.END_OBJECT) {\n                _nextToken = JsonToken.END_ARRAY;\n            } else {\n                _nextToken = null;\n            }\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    // DEBUGGING\n    /*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n            switch (t) {\n            case FIELD_NAME:\n                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n                break;\n            case VALUE_STRING:\n                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n                break;\n            default:\n                System.out.println(\"JsonToken: \"+t);\n            }\n        }\n        return t;\n    }\n\n//    public JsonToken nextToken0() throws IOException\n */\n\n    \n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n",
    "label": "buggy",
    "id": "34578480-028b-4e88-8eb7-38cfaa15d459"
  },
  {
    "project": "Jsoup",
    "bug_id": "46",
    "file": "org/jsoup/nodes/Entities.java",
    "snippet": "    /**\n     * Get the Character value of the named entity\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n     */\n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }\n\n    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n",
    "label": "buggy",
    "id": "3a4129ff-2b42-4b16-9753-807e4b1c7cf3"
  },
  {
    "project": "Time",
    "bug_id": "13",
    "file": "org/joda/time/format/PeriodFormatterBuilder.java",
    "snippet": "        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 or 5 digits with a negative\n                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n",
    "label": "clean",
    "id": "de1985be-cab1-45e4-aa0d-c52ec1a14c45"
  },
  {
    "project": "Lang",
    "bug_id": "7",
    "file": "org/apache/commons/lang3/math/NumberUtils.java",
    "snippet": "    /**\n     * <p>Convert a <code>String</code> to an <code>short</code>, returning a\n     * default value if the conversion fails.</p>\n     *\n     * <p>If the string is <code>null</code>, the default value is returned.</p>\n     *\n     * <pre>\n     *   NumberUtils.toShort(null, 1) = 1\n     *   NumberUtils.toShort(\"\", 1)   = 1\n     *   NumberUtils.toShort(\"1\", 0)  = 1\n     * </pre>\n     *\n     * @param str  the string to convert, may be null\n     * @param defaultValue  the default value\n     * @return the short represented by the string, or the default if conversion fails\n     * @since 2.5\n     */\n    public static short toShort(String str, short defaultValue) {\n        if(str == null) {\n            return defaultValue;\n        }\n        try {\n            return Short.parseShort(str);\n        } catch (NumberFormatException nfe) {\n            return defaultValue;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    // must handle Long, Float, Integer, Float, Short,\n    //                  BigDecimal, BigInteger and Byte\n    // useful methods:\n    // Byte.decode(String)\n    // Byte.valueOf(String,int radix)\n    // Byte.valueOf(String)\n    // Double.valueOf(String)\n    // Float.valueOf(String)\n    // Float.valueOf(String)\n    // Integer.valueOf(String,int radix)\n    // Integer.valueOf(String)\n    // Integer.decode(String)\n    // Integer.getInteger(String)\n    // Integer.getInteger(String,int val)\n    // Integer.getInteger(String,Integer val)\n    // Integer.valueOf(String)\n    // Double.valueOf(String)\n    // new Byte(String)\n    // Long.valueOf(String)\n    // Long.getLong(String)\n    // Long.getLong(String,int)\n    // Long.getLong(String,Integer)\n    // Long.valueOf(String,int)\n    // Long.valueOf(String)\n    // Short.valueOf(String)\n    // Short.decode(String)\n    // Short.valueOf(String,int)\n    // Short.valueOf(String)\n    // new BigDecimal(String)\n    // new BigInteger(String)\n    // new BigInteger(String,int radix)\n    // Possible inputs:\n    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n    // plus minus everything. Prolly more. A lot are not separable.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n",
    "label": "buggy",
    "id": "cd067e82-c192-4887-a980-b190f403e591"
  },
  {
    "project": "Cli",
    "bug_id": "27",
    "file": "org/apache/commons/cli/OptionGroup.java",
    "snippet": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @author John Keyes ( john at integralsource.com )\n * @version $Revision$, $Date$\n */\npublic class OptionGroup implements Serializable\n{\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private Map optionMap = new HashMap();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n",
    "label": "clean",
    "id": "e6470e21-8b8b-4c17-824b-992ed6a228e0"
  },
  {
    "project": "Lang",
    "bug_id": "31",
    "file": "org/apache/commons/lang3/StringUtils.java",
    "snippet": "    /**\n     * <p>Checks if the CharSequence contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\t\tint csLength = cs.length();\n\t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n\t\tfor (int i = 0; i < csLength; i++) {\n\t\t\tchar ch = cs.charAt(i);\n\t\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\t\tif (searchChars[j] == ch) {\n",
    "label": "clean",
    "id": "647cf4ab-6867-45f3-a9b5-2f75621f5671"
  },
  {
    "project": "Gson",
    "bug_id": "13",
    "file": "com/google/gson/stream/JsonReader.java",
    "snippet": "  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n",
    "label": "clean",
    "id": "86cbf0c9-ec74-45fb-afbb-499231bc742f"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "23",
    "file": "com/fasterxml/jackson/databind/ser/std/NumberSerializers.java",
    "snippet": "/**\n * Container class for serializers used for handling standard JDK-provided types.\n */\n@SuppressWarnings(\"serial\")\npublic class NumberSerializers\n{\n    protected NumberSerializers() { }\n\n    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)\n    {\n        final JsonSerializer<?> intS = new IntegerSerializer();\n        allDeserializers.put(Integer.class.getName(), intS);\n        allDeserializers.put(Integer.TYPE.getName(), intS);\n        allDeserializers.put(Long.class.getName(), LongSerializer.instance);\n        allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance);\n        allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Short.class.getName(), ShortSerializer.instance);\n        allDeserializers.put(Short.TYPE.getName(), ShortSerializer.instance);\n\n        // Numbers, limited length floating point\n        allDeserializers.put(Float.class.getName(), FloatSerializer.instance);\n        allDeserializers.put(Float.TYPE.getName(), FloatSerializer.instance);\n        allDeserializers.put(Double.class.getName(), DoubleSerializer.instance);\n        allDeserializers.put(Double.TYPE.getName(), DoubleSerializer.instance);\n    }\n\n    /*\n    /**********************************************************\n    /* Shared base class\n    /**********************************************************\n     */\n\n    protected abstract static class Base<T> extends StdScalarSerializer<T>\n        implements ContextualSerializer\n    {\n\n        protected final JsonParser.NumberType _numberType;\n        protected final String _schemaType;\n        protected final boolean _isInt;\n\n",
    "label": "buggy",
    "id": "bc118bed-81fe-4ef9-8481-dd25e007a875"
  },
  {
    "project": "JacksonCore",
    "bug_id": "13",
    "file": "com/fasterxml/jackson/core/json/JsonGeneratorImpl.java",
    "snippet": "    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        super.enable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = false;\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        super.disable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = true;\n        }\n",
    "label": "clean",
    "id": "13ab5933-c210-470e-84c9-15192189262a"
  },
  {
    "project": "Math",
    "bug_id": "106",
    "file": "org/apache/commons/math/fraction/ProperFractionFormat.java",
    "snippet": "    /**\n     * Parses a string to produce a {@link Fraction} object.  This method\n     * expects the string to be formatted as a proper fraction.\n     * <p>\n     * Minus signs are only allowed in the whole number part - i.e.,\n     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n     * will result in a <code>ParseException</code>.\n     * \n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Fraction} object.\n     */\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        \n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n        \n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n            // minus signs should be leading, invalid expression\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n",
    "label": "buggy",
    "id": "7a9ab0c1-3b2e-49ce-9e96-e77d90d54bb9"
  },
  {
    "project": "Cli",
    "bug_id": "38",
    "file": "org/apache/commons/cli/DefaultParser.java",
    "snippet": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @version $Id$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n    \n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n \n    /** The last option parsed. */\n    protected Option currentOption;\n \n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n \n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        // check for several concatenated short options\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n",
    "label": "clean",
    "id": "74a30bed-7543-4fab-bce9-bd0473b9e89d"
  },
  {
    "project": "Csv",
    "bug_id": "2",
    "file": "org/apache/commons/csv/CSVRecord.java",
    "snippet": "    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n            return index != null ? values[index.intValue()] : null;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n",
    "label": "buggy",
    "id": "a94aea4c-4800-4b74-b0b0-de8856dd3641"
  },
  {
    "project": "Closure",
    "bug_id": "99",
    "file": "com/google/javascript/jscomp/CheckGlobalThis.java",
    "snippet": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n",
    "label": "clean",
    "id": "338ac02d-ebbb-470e-8614-bb025a6ca139"
  },
  {
    "project": "Lang",
    "bug_id": "6",
    "file": "org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
    "snippet": "    /**\n     * Helper for non-Writer usage. \n     * @param input CharSequence to be translated\n     * @return String output of translation\n     */\n    public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            throw new RuntimeException(ioe);\n        }\n    }\n\n    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }\n\n    /**\n",
    "label": "clean",
    "id": "1c078024-a3cb-445e-97ff-11ad42915755"
  },
  {
    "project": "Math",
    "bug_id": "92",
    "file": "org/apache/commons/math/util/MathUtils.java",
    "snippet": "    /**\n     * Returns an exact representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>long</code>. The\n     * largest value of <code>n</code> for which all coefficients are\n     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n     * thrown.</li>\n     * </ul></p>\n     * \n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     * @throws ArithmeticException if the result is too large to be represented\n     *         by a long integer.\n     */\n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        long result = Math.round(binomialCoefficientDouble(n, k));\n        if (result == Long.MAX_VALUE) {\n            throw new ArithmeticException(\n                \"result too large to represent in a long integer\");\n        }\n        // Use symmetry for large k\n",
    "label": "buggy",
    "id": "28b7a09a-a844-4165-966b-156d288d0019"
  },
  {
    "project": "Collections",
    "bug_id": "1",
    "file": "org/apache/commons/collections/map/Flat3Map.java",
    "snippet": "    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator implements MapIterator, ResettableIterator {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n",
    "label": "clean",
    "id": "ceeb7e57-fc2e-449a-88ce-28f9c0e8e038"
  },
  {
    "project": "Jsoup",
    "bug_id": "24",
    "file": "org/jsoup/parser/TokeniserState.java",
    "snippet": "/**\n * States and transition activations for the Tokeniser.\n */\nenum TokeniserState {\n    Data {\n        // in data state, gather characters until a character reference or tag is found\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        // from & in data\n        void read(Tokeniser t, CharacterReader r) {\n            Character c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Data);\n        }\n    },\n    Rcdata {\n        /// handles data in title, textarea etc\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            Character c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(RawtextLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(ScriptDataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        // from < in data\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        // from < or </ in data, will have start or end tag pending\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            String tagName = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                // no default, as covered with above consumeToAny\n            }\n        }\n    },\n    RcdataLessthanSign {\n        // from < in rcdata\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(RawtextEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                }\n            } else\n                anythingElse(t, r);\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(ScriptDataEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptData);\n            }\n\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n",
    "label": "clean",
    "id": "96449e19-b95e-42dd-bc25-f1b74c34e634"
  },
  {
    "project": "Math",
    "bug_id": "23",
    "file": "org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
    "snippet": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n",
    "label": "clean",
    "id": "32d9eea8-1c54-4682-9754-c97d9fbbf56e"
  },
  {
    "project": "Math",
    "bug_id": "102",
    "file": "org/apache/commons/math/stat/inference/ChiSquareTestImpl.java",
    "snippet": "    /**\n     * Create a test instance using the given distribution for computing\n     * inference statistics.\n     * @param x distribution used to compute inference statistics.\n     * @since 1.2\n     */\n    public ChiSquareTestImpl(ChiSquaredDistribution x) {\n        super();\n        setDistribution(x);\n    }\n     /**\n     * {@inheritDoc}\n     * <p><strong>Note: </strong>This implementation rescales the \n     * <code>expected</code> array if necessary to ensure that the sum of the\n     * expected and observed counts are equal.</p>\n     * \n     * @param observed array of observed frequency counts\n     * @param expected array of expected frequency counts\n     * @return chi-square test statistic\n     * @throws IllegalArgumentException if preconditions are not met\n     * or length is less than 2\n     */\n    public double chiSquare(double[] expected, long[] observed)\n        throws IllegalArgumentException {\n        if ((expected.length < 2) || (expected.length != observed.length)) {\n            throw new IllegalArgumentException(\n                    \"observed, expected array lengths incorrect\");\n        }\n        if (!isPositive(expected) || !isNonNegative(observed)) {\n            throw new IllegalArgumentException(\n                \"observed counts must be non-negative and expected counts must be postive\");\n        }\n        double sumExpected = 0d;\n        double sumObserved = 0d;\n        for (int i = 0; i < observed.length; i++) {\n            sumExpected += expected[i];\n            sumObserved += observed[i];\n        }\n",
    "label": "clean",
    "id": "4bfdb3c3-4e3c-4229-b97a-f9e0a86124e2"
  },
  {
    "project": "JacksonCore",
    "bug_id": "26",
    "file": "com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java",
    "snippet": "    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n",
    "label": "clean",
    "id": "21872842-42ef-477d-b468-429cad37f57f"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "54",
    "file": "com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
    "snippet": "    /**********************************************************\n     */\n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (declaredType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n",
    "label": "buggy",
    "id": "047e17fc-a4e6-4c97-84f6-80d3f30cd3c8"
  },
  {
    "project": "JacksonDatabind",
    "bug_id": "18",
    "file": "com/fasterxml/jackson/databind/MappingIterator.java",
    "snippet": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Iterator exposed by {@link ObjectMapper} when binding sequence of\n * objects. Extension is done to allow more convenient exposing of\n * {@link IOException} (which basic {@link Iterator} does not expose)\n */\npublic class MappingIterator<T> implements Iterator<T>, Closeable\n{\n    protected final static MappingIterator<?> EMPTY_ITERATOR =\n        new MappingIterator<Object>(null, null, null, null, false, null);\n\n    /*\n    /**********************************************************\n    /* State constants\n    /**********************************************************\n     */\n\n    /**\n     * State in which iterator is closed\n     */\n    protected final static int STATE_CLOSED = 0;\n    \n    /**\n     * State in which value read failed\n     */\n    protected final static int STATE_NEED_RESYNC = 1;\n",
    "label": "clean",
    "id": "b3609895-1fcd-4502-97f9-b6c99c621161"
  },
  {
    "project": "Cli",
    "bug_id": "24",
    "file": "org/apache/commons/cli/HelpFormatter.java",
    "snippet": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n",
    "label": "clean",
    "id": "2a57e1d3-508b-441e-b7d4-e800dc4d6e7a"
  },
  {
    "project": "Math",
    "bug_id": "42",
    "file": "org/apache/commons/math/optimization/linear/SimplexTableau.java",
    "snippet": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n",
    "label": "clean",
    "id": "e41098e3-2e27-440a-bc21-380c427f31f9"
  },
  {
    "project": "Jsoup",
    "bug_id": "20",
    "file": "org/jsoup/helper/DataUtil.java",
    "snippet": "/**\n * Internal static utilities for handling data.\n *\n */\npublic class DataUtil {\n    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n    static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n    private static final int bufferSize = 0x20000; // ~130K.\n\n    private DataUtil() {}\n\n    /**\n     * Loads a file to a Document.\n     * @param in file to load\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        FileInputStream inStream = null;\n        try {\n            inStream = new FileInputStream(in);\n            ByteBuffer byteData = readToByteBuffer(inStream);\n            return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n        } finally {\n            if (inStream != null)\n                inStream.close();\n        }\n    }\n\n    /**\n     * Parses a Document from an input steam.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    /**\n     * Parses a Document from an input steam, using the provided Parser.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, parser);\n    }\n\n    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n",
    "label": "buggy",
    "id": "cd98e685-82c5-4367-9bb9-abf29f8a50e4"
  }
]